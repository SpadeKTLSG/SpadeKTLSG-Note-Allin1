--计算机网络以及相关内容的探索

‍

### Header

‍

‍

# 科班个人记录

> 课堂期末整理后留下的遗产, 网络和个人主要开发方向接触面很宽, 因此内容巨多
>
> 也包括课余收集的网络知识

‍

## IP地址相关

‍

### **分类**

‍

#### **公有IP**

A类：10.0.0.0到127.255.255.255主要分配给大量主机而局域网网络数量较少的大型网络

B类：128.0.0.0到191.255.255.255一般用于国际性大公司和政府机构

C类：192.0.0.0到223.255.255.255用于一般小公司校园网研究机构等

D类：224.0.0.0到239.255.255.255用于特殊用途，又称作广播地址

E类：240.0.0.0到255.255.255.255暂时保留

‍

‍

#### **私有IP**

10.XXX

172.16.XXX - 172.31.255.255

192.168.XXX

‍

‍

### NAT地址转换

私网地址如何访问互联网呢？这就需要用到NAT地址转换，将内网地址映射到外网地址。

NAT的核心是一张映射表（源IP地址，源端口，目的IP地址，目的端口），将内网源IP地址和端口映射到同一个公网地址的不同端口

‍

‍

## 掌握协议

* 应用层协议

  * HTTP 协议（超文本传输协议，网页浏览常用的协议）
  * DHCP 协议（动态主机配置）
  * DNS 系统原理（域名系统）
  * FTP 协议（文件传输协议）
  * 电子邮件协议等（SMTP、POP3、IMAP）
  * P2P 架构
* 传输层协议
* TCP 协议
* 报文段结构
* 可靠数据传输
* 流量控制
* 拥塞控制
* UDP 协议
* 报文段结构
* RDT（可靠数据传输协议）
* 网络层协议
* IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）
* ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）
* ICMP 协议（控制报文协议，用于发送控制消息）
* NAT 协议（网络地址转换协议）
* RIP 协议、OSPF 协议、BGP 协议（路由选择协议）
* 链路层
* 差错检测技术
* 多路访问协议（信道复用技术）
* CSMA/CD 协议
* MAC 协议
* 以太网技术
* 物理层（对计算机专业的小伙伴来说，在课程要求中，物理层的内容可能相对不那么重要）

‍

‍

‍

‍

# 开发相关

‍

‍

## 网络通信协议 - 模型

|OSI参考模型|TCP/IP参考模型|TCP/IP参考模型各层对应协议|
| ------------------------| -----------------| ----------------------------|
|应用层、表示层、会话层|应用层|HTTP、FTP、Telnet、DNS...|
|传输层|传输层|TCP、UDP、...|
|网络层|网络层|IP、ICMP、ARP...|
|数据链路层|物理+数据链路层|Link|

‍

## 跨域

‍

浏览器同源策略 1995年，同源政策由 Netscape 公司引入浏览器. 目前，所有浏览器都实行这个政策.

最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页"同源". 所谓"同源"指的是"三个相同"

> 协议相同  http https  
> 域名相同  www.xdclass.net  
> 端口相同  80  81

‍

一句话：浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域

浏览器控制台跨域提示：  
No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.

‍

区分维度：

* 协议
* IP/协议
* 端口

只要上述的三个维度有任何一个维度不同，那就是跨域操作

‍

‍

## 服务器集群

‍

现在所开发的项目一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题: 单点故障 -- 一旦这台服务器挂了，整个应用都没法访问了. 所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份

用户在访问的时候，他会访问一台前置的服务器，我们叫**负载均衡服务器**, 它将前端发起的请求均匀的分发给真正的服务器

‍

‍

## SSL TLS

‍

SSL(Secure Socket Layer 安全套接层)是基于 HTTPS 下的一个协议加密层

起初是因为HTTP在传输数据时使用的是明文. 为了解决这一隐患网景公司推出了SSL安全套接字协议层，SSL 是基于 HTTP 之下 TCP 之上的一个协议层，基于 HTTP 标准并对 TCP 传输数据时进行加密，所以 HTTPS 是 HTTP+SSL/TCP的简称.

‍

由于 HTTPS 的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时，IETF 对 SSL3.0 进行了标准化，并添加了少数机制，标准化后的 IETF 更名为 TLS1.0(Transport Layer Security 安全传输层协议)，可以说 TLS 就是 SSL 的新版本 3.1

‍

TLS（Transport Layer Security）是更为安全的升级版 SSL. 但 SSL 这一术语更为常用，实际上 MySQL 使用的就是 TLS 协议，而不是 SSL 协议

‍

‍

## 同步异步

‍

* 同步    浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作
* 异步    浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作
* 异步交互    在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术

‍

‍

## URL

统⼀资源定位符，获取服务器资源的一种

‍

标准格式: `协议://服务器IP:端⼝/路径1/路径N ? key1=value1 & key2=value2`​

* 协议：不同的协议有不同的解析⽅式
* 服务器ip: ⽹络中存在⽆数的主机,要访问的哪⼀台, 通过公⽹ip区分
* 端⼝: ⼀台主机上运⾏着很多的进程，为了区分不同进程，⼀个端⼝对应⼀个进程，http默认的端⼝是80
* 路径: 资源N多种，为了更进⼀步区分资源所在的路径（后端接⼝，⼀般称为 “接⼝路径”，“接⼝”）

‍

‍

## 网络通信

‍

**网络编程目的**

直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯.

‍

**网络编程主要的问题**

如何准确地定位网络上一台或多台主机

定位主机上的特定的应用

找到主机后如何可靠高效地进行数据传输

‍

‍

### 三要素

‍

> 网络三要素
>
> * IP ：网络中计算机的唯一标识
> * 端口 ：计算机中运行程序的唯一标识
> * 协议 ：网络中计算机之间交互的规则

‍

‍

## IP

‍

IP地址    InetAddress

唯一的标识Internet 上的计算机（通信实体）

本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost

‍

Internet上的主机有两种方式表示地址：

域名(hostName)：www.atguigu.com

IP地址(hostAddress)：202.108.35.210

‍

‍

**IPV4和IPV6**

‍

IPV4：4个字节组成，4个0-255. 大概42亿，30亿都在北美，亚洲4亿. 2011年初已经用尽. 以点分十进制表示，如192.168.0.1

IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984

‍

**公网地址(万维网使用)和私有地址(局域网使用)**

‍

192.168.开头的就是私有地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用  
    特点：不易记忆

‍

‍

‍

‍

‍

## 端口

端口号标识正在计算机上运行的进程（程序）  
不同的进程有不同的端口号, 被规定为一个16 位的整数0~65535.

‍

公认端口：0~1023. 被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）

‍

注册端口：1024-49151. 分配给用户进程或应用程序. （如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）.

‍

动态/私有端口：49152~65535.

‍

端口号与IP地址的组合得出一个网络套接字：Socket.

‍

‍

‍

tomcat    8080

mysql    3306

http    80

https    443

‍

‍

‍

‍

‍

‍

## Web服务器

‍

Web应用程序    可以提供浏览器访问的程序

‍

**服务器**，也称**伺服器**. 是提供计算服务的设备. 由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力.

构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高.

网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等

服务器只是一台设备，必须安装服务器软件才能提供相应的服务.

‍

服务器软件：基于ServerSocket编写的程序

* 服务器软件本质是一个运行在服务器设备上的应用程序
* 能够接收客户端请求，并根据请求给客户端响应数据

‍

Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷. 主要功能是"提供网上信息浏览服务"

‍

‍

### 运行流程

1. 前端的代码通过浏览器转化（解析和渲染）成用户看到的网页
2. 浏览器中对代码进行解析和渲染的部分，称为浏览器内核
3. 任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上
4. Web分为静态和动态, Java中动态Web资源开发的技术统称为JavaWeb

‍

浏览器输入一个地址，到页面展示中间经历了哪些处理

    1、浏览器输入url, 解析url地址是否合法

　　2、浏览器检查是否有缓存, 如果有直接显示. 如果没有跳到第三步.

　　3、在发送http请求前，需要域名解析（DNS解析），解析获取对应过的ip地址.

　　4、浏览器向服务器发起tcp链接，完成tcp三次握手

　　5、握手成功后，浏览器向服务器发送http请求

　　6、服务器收到处理的请求，将数据返回至浏览器

　　7、浏览器收到http响应.

　　8、浏览器解析响应. 如果响应可以缓存，则存入缓存

　　9、浏览器进行页面渲染

‍

## 网页类型

‍

‍

### 静态网页

无法动态更新(有一些点击特效可以实现伪动态), 无法和数据库交互

* 主要指的是网页中没有程序代码，主要是HTML+CSS+JS,一般后缀为.html,htm
* 任何人任何时间打开的页面的内容都是不变的

‍

### 动态网页

页面动态展示, 可以和数据库交互. 资源出现问题时需要重新编写后台程序重新发布(停机维护)

* 前端：HTML + CSS + JS + HTTP
* 后端：Servlet+Request+Response+Cookie+Session
* 数据库(类似excel)：Mysql
* 浏览器和服务器进行数据交互，服务器端根据客户的不同请求动态的生成网页内容

‍

‍

‍

‍

‍

## 通信协议

TCP协议与UDP协议

‍

### TCP

应用进程:客户端、服务端

‍

使用TCP协议前，须先建立TCP连接，形成基于字节流的传输数据通道

传输前，采用"三次握手","三次挥手"方式，点对点通信，是可靠的

‍

TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息.

第一次握手，客户端向服务器端发起TCP连接的请求

第二次握手，服务器端发送针对客户端TcP连接请求的确认

第三次握手，客户端发送确认的确认

‍

另外,四次挥手

‍

‍

在连接中可进行大数据量的传输

传输完毕，**需释放已建立的连接，效率低**

好似**打电话**

‍

‍

### UDP

‍

应用进程:发送端、接收端

将数据、源、目的封装成数据包(传输的基本单位)，不需要建立连接

发送不管对方是否准备好，接收方收到也不确认，不能保证数据的完整性，故是不可靠的

每个数据报的大小限制在64K内

发送数据结束时无需释放资源，开销小，通信效率高

适用场景:音频、视频和普通数据的传输. 例如视频会议

好似**发短信**

‍

‍

‍

## WEB标准

‍

结构化标准语言(HTML,XML)

表现标准语言(CSS)

行为标准(DOM,ECMAScript)

‍

Web标准也称为网页标准，由一系列的标准组成，大部分由W3C<sup>(World Wide Web Consortium，万维网联盟)</sup>负责制定：

HTML：负责网页的结构（页面元素和内容）  
CSS：负责网页的表现（页面元素的外观、位置等页面样式）  
JavaScript：负责网页的行为（交互效果）

‍

‍

‍

‍

## HTTP

Hyper Text Transfer Protocol(超文本传输协议), HTTP协议规定了浏览器与服务器之间数据传输的规则, 要求浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输

‍

HTTP协议又分为

‍

请求协议：浏览器将数据以请求格式发送到服务器

* 包括：**请求行**、**请求头** 、**请求体**

响应协议：服务器将数据以响应格式返回给浏览器

* 包括：**响应行** 、**响应头** 、**响应体**

‍

你知道http和https的区别不，简单说下

* HTTPS = HTTP + SSL
* https有ca证书，http一般没有
* http是超文本传输协议，信息是明文传输. https则是具有安全性的ssl加密传输协议
* http默认80端口，https默认443端口.

‍

### 特点

‍

* **基于TCP协议:**   面向连接，建立连接之前是需要经过三次握手, 安全
* **基于请求-响应模型:**   一次请求对应一次响应（先请求后响应）
* **HTTP协议是无状态协议:**   对于数据没有记忆能力, 速度快, 每次请求-响应都是独立的

‍

* http请求分为三部分：请求行，请求头， 请求体
* 请求头

  * 报文头包含若干个属性 格式为“属性名:属性值”，
  * 服务端据此获取客户端的基本信息

‍

### 和https的关系

Hyper Text Transfer Protocol over SecureSocket Layer

* 主要由两部分组成：HTTP + SSL / TLS
* 比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性,增加破解成本
* 缺点：相同网络环境下，HTTPS 协议会使页面的加载时间延长近 50%，增加额外的计算资源消耗，增加 10%到 20%的耗电等；不过利大于弊，所以Https是趋势，相关资源损耗也在持续下降
* 如果做软件压测：直接压测内网ip，通过压测公网域名，不管是http还是https，都会带来额外的损耗导致结果不准确

* https有ca证书，http一般没有
* http是超文本传输协议，信息是明文传输. https则是具有安全性的ssl加密传输协议
* http默认80端口，https默认443端口.

‍

### 请求协议

‍

‍

‍

|请求方式|请求说明|
| ----------| ----------------------------------------------------------------------------------------------------------|
|**GET**|获取资源. <br />向特定的资源发出请求.|
|**POST**|==传输实体主体==<br />向指定资源提交数据进行处理请求，数据被包含在请求体中|
|OPTIONS|返回服务器针对特定资源所支持的==HTTP请求方式==<br />并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些<br />|
|HEAD|==获得报文首部==<br />HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据<br />通常用于确认URI的有效性及资源更新时间等<br />|
|PUT|==传输文件==<br />类似FTP协议，文件内容包含在请求报文的实体中<br />然后请求保存到URL指定的服务器位置<br />|
|DELETE|==删除文件==<br />请求服务器删除Request-URI所标识的资源|
|TRACE|==追踪路径==<br />回显服务器收到的请求，主要用于测试或诊断|
|CONNECT|==要求用隧道协议连接代理==<br />HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器|

‍

http1.0定义了三种：

* GET: 向服务器获取资源，比如常见的查询请求
* POST: 向服务器提交数据而发送的请求
* Head: 和get类似，返回的响应中没有具体的内容，用于获取报头

http1.1定义了六种

* PUT：一般是用于更新请求，比如更新个人信息、商品信息全量更新
* PATCH：PUT 方法的补充,更新指定资源的部分数据
* DELETE：用于删除指定的资源
* OPTIONS: 获取服务器支持的HTTP请求方法,服务器性能、跨域检查等
* CONNECT: 方法的作用就是把服务器作为跳板，让服务器代替用户去访问其它网页，之后把数据原原本本的返回给用户，网页开发基本不用这个方法，如果是http代理就会使用这个，让服务器代理用户去访问其他网页，类似中介
* TRACE：回显服务器收到的请求，主要用于测试或诊断

‍

Con Tra基本用不到

‍

#### 请求行

‍

HTTP请求中的第一行数据. 由：`请求方式`​、`资源路径`​、`协议/版本`​组成（之间使用空格分隔）

‍

请求方式：GET(举例)

资源路径：/brand/findAll?name=OPPO&status=1

* 请求路径：/brand/findAll
* 请求参数：name=OPPO&status=1

  * 请求参数是以key=value形式出现
  * 多个请求参数之间使用`&`​连接
* 请求路径和请求参数之间使用`?`​连接

协议/版本：HTTP/1.1

‍

#### 请求头

‍

第二行开始是请求头. 格式为key: value形式

http是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式

‍

==常见请求头==

|Host|请求的主机名|
| :---------------: | ----------------------------------------------------------|
|User-Agent|浏览器版本，例如Chrome浏览器的标识类似Chrome/79|
|Accept|表示浏览器能接收的资源类型，如text/ *，image/* 或者 */* 表示所有；|
|Accept-Language|表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；|
|Accept-Encoding|表示浏览器可以支持的压缩类型，例如gzip, deflate等.|
|Content-Type|请求主体的数据类型.|
|Content-Length|请求主体的大小（单位：字节）.|

‍

#### 请求体

存储请求参数, 请求体和请求头之间是有一个空行隔开, 用于标记请求头结束

* GET请求的请求参数在请求行中，故不需要设置请求体
* POST就需要{key:value}格式的请求体

‍

常见的请求头

* Accept： 览器支持的 MIME 媒体类型, 比如 text/html,application/json,image/webp, */*  等
* Accept-Encoding: 浏览器发给服务器,声明浏览器支持的编码类型，gzip, deflate
* Accept-Language: 客户端接受的语言格式,比如 zh-CN
* Connection: keep-alive , 开启HTTP持久连接
* Host：服务器的域名
* Origin：告诉服务器请求从哪里发起的，仅包括协议和域名 CORS跨域请求中可以看到response有对应的header，Access-Control-Allow-Origin
* **Referer**：告诉服务器请求的原始资源的URI，其用于所有类型的请求，并且包括：协议+域名+查询参数； 很多抢购服务会用这个做限制，必须通过某个入来进来才有效(设定直接访问接口是作弊行为)
* User-Agent: 服务器通过这个请求头判断用户的软件的应用类型、操作系统、软件开发商以及版本号、浏览器内核信息等； 风控系统、反作弊系统、反爬虫系统等基本会采集这类信息做参考
* Cookie: 表示服务端给客户端传的http请求状态,也是多个key=value形式组合，比如登录后的令牌等
* Content-Type： HTTP请求提交的内容类型，一般只有post提交时才需要设置，比如文件上传，表单提交等

‍

‍

#### 特殊

‍

GET/POST 请求方式的区别

|区别方式|GET请求|POST请求|
| --------------| -------------------------------------------------------------| ----------------------|
|请求参数|请求参数在请求行中. <br />例：/brand/findAll?name=OPPO&status=1|请求参数在请求体中|
|请求参数长度|请求参数长度有限制(浏览器不同限制也不同)|请求参数长度没有限制|
|安全性|安全性低. 原因：请求参数暴露在浏览器地址栏中.|安全性相对高|

‍

‍

### 响应协议

‍

‍

#### 响应行

‍

响应数据的第一行. 响应行由`协议及版本`​、`响应状态码`​、`状态码描述`​组成

* 协议/版本：HTTP/1.1
* 响应状态码：200
* 状态码描述：OK

‍

‍

#### 响应头

‍

响应数据的第二行开始. 格式为key：value形式

‍

==常见HTTP响应头==

|Content-Type|表示该响应内容的类型，例如text/html，application/json.|
| ------------------| -------------------------------------------------------------|
|Content-Length|表示该响应内容的长度（字节数）.|
|Content-Encoding|表示该响应压缩算法，例如gzip.|
|Cache-Control|指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒.|
|Set-Cookie|告诉浏览器为当前页面所在的域设置cookie.|

‍

‍

#### 响应体

‍

响应数据的最后一部分. 存储响应的数据

响应体和响应头之间有一个空行隔开, 用于标记响应头结束

‍

‍

#### 响应状态码

‍

|状态码分类|说明|
| :----------: | ---------------------------------------------------------------------------------------------------|
|1xx|**响应中** --- 临时状态码. 表示请求已经接受，<br />告诉客户端应该继续请求或者如果已经完成则忽略<br />|
|2xx|**成功** --- 表示请求已经被成功接收，处理已完成|
|3xx|**重定向** --- 重定向到其它地方，<br />让客户端再发起一个请求以完成整个处理<br />|
|4xx|**客户端错误** --- 处理发生错误，责任在客户端，<br />如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等<br />|
|5xx|**服务器端错误** --- 处理发生错误，责任在服务端，<br />如：服务端抛出异常，路由出错，HTTP版本不支持等<br />|

‍

==主要状态码==

* 200 ok 客户端请求成功
* 404 Not Found 请求资源不存在
* 500 Internal Server Error 服务端发生不可预期的错误

‍

==状态码全集==

|状态码|英文描述|解释|
| --------| ----------| ----------------------------------------------------------------------------------------------|
|==200==|​**​`OK`​**​|客户端请求成功，即**处理成功**，这是我们最想看到的状态码|
|302|​**​`Found`​**​|指示所请求的资源已移动到由`Location`​响应头给定的 URL，<br />浏览器会自动重新访问到这个页面<br />|
|304|​**​`Not Modified`​**​|隐式重定向<sup>（ 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧. ）</sup>|
|400|​**​`Bad Request`​**​|客户端请求有**语法错误**，不能被服务器所理解|
|403|​**​`Forbidden`​**​|服务器收到请求，但是**拒绝提供服务**|
|==404==|​**​`Not Found`​**​|**请求资源不存在**，一般是URL输入有误，或者网站资源被删除了|
|405|​**​`Method Not Allowed`​**​|请求方式有误，比如应该用GET请求方式的资源，用了POST|
|428|​**​`Precondition Required`​**​|**服务器要求有条件的请求**，<br />告诉客户端要想访问该资源必须携带特定的请求头<br />|
|429|​**​`Too Many Requests`​**​|指示用户在给定时间内发送了**太多请求**（“限速”）<br />配合 Retry-After(多长时间后可以请求)响应头一起使用<br />|
|431|​**​`Request Header Fields Too Large`​**​|**请求头太大**，服务器不愿意处理请求|
|==500==|​**​`Internal Server Error`​**​|**服务器发生不可预期的错误**|
|503|​**​`Service Unavailable`​**​|**服务器尚未准备好处理请求**，服务器还未初始化好|

‍

‍

**分类**

* 1XX: 收到请求，需要请求者继续执行操作，比较少用
* 2XX: 请求成功，常用的 200
* 3XX: 重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取；

  * 好处：网站改版、域名迁移等，多个域名指向同个主站导流
  * 必须记住：

    301：永久性跳转，比如域名过期，换个域名直接到新的域名去

    302：临时性跳转
* 4XX: 客服端出错，请求包含语法错误或者无法完成请求

  * 400: 请求出错，比如语法协议

    403: 没权限访问 404: 找不到这个路径对应的接口或者文件 405: 不允许此方法进行提交，Method not allowed，比如接口一定要POST方式，而你是用了GET
* 5XX: 服务端出错，服务器在处理请求的过程中发生了错误

  * 必须记住： 500: 服务器内部报错了，完成不了这次请求 503: 服务器宕机

‍

## **Http超文本传输协议**和https的关系

* Hyper Text Transfer Protocol over SecureSocket Layer
* 主要由两部分组成：HTTP + SSL / TLS
* 比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性,增加破解成本
* 缺点：相同网络环境下，HTTPS 协议会使页面的加载时间延长近 50%，增加额外的计算资源消耗，增加 10%到 20%的耗电等；不过利大于弊，所以Https是趋势，相关资源损耗也在持续下降
* 如果做软件压测：直接压测内网ip，通过压测公网域名，不管是http还是https，都会带来额外的损耗导致结果不准确

‍

‍

‍

‍

## Http响应头知识点讲解

**简介：讲解Http响应头知识点**

* 响应头

  * 报文头包含若干个属性 格式为“属性名:属性值”
* 常见的响应头

  * Allow: 服务器支持哪些请求方法
  * Content-Length: 响应体的字节长度
  * Content-Type: 响应体的MIME类型
  * Content-Encoding: 设置数据使用的编码类型
  * Date: 设置消息发送的日期和时间
  * Expires: 设置响应体的过期时间,一个GMT时间，表示该缓存的有效时间
  * cache-control: Expires的作用一致，都是指明当前资源的有效期, 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据,优先级高于Expires,控制粒度更细，如max-age=240，即4分钟
  * Location：表示客户应当到哪里去获取资源，一般同时设置状态代码为3xx
  * Server: 服务器名称
  * Transfer-Encoding：chunked 表示输出的内容长度不能确定，静态网页一般没，基本出现在动态网页里面
  * Access-Control-Allow-Origin: 定哪些站点可以参与跨站资源共享

‍

## Http常见请求/响应头content-type内容类型讲解

**简介：讲解Http里面的content-type媒体类型讲解**

* Content-type: 用来指定不同格式的请求响应信息，俗称 MIME媒体类型
* 常见的取值  
  text/html ：HTML格式 text/plain ：纯文本格式  
  text/xml ： XML格式  
  image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式  
  application/json：JSON数据格式 application/pdf ：pdf格式 application/octet-stream ：二进制流数据，一般是文件下载  
  application/x-www-form-urlencoded：form表单默认的提交数据的格式，会编码成key=value格式  
  multipart/form-data： 表单中需要上传文件的文件格式类型
* Http知识加深文档：[https://developer.mozilla.org/zh-CN/docs/Web/HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)

‍

## 同端口占用问题

[Link](https://www.code-nav.cn/post/1750117490454700034#heading-1)

**同一个端口只能被一个程序占用? NO**

‍

不同的网络协议是可以共享同一端口的, 例如IPv4与IPv6, TCP 和 UDP

‍

‍

‍

**localhost 不等于 127.0.0.1**

‍

首先，`localhost`​ 和 `127.0.0.1`​ 完全是两个不同的概念！

localhost 是 **主机名** （hostname），它通常被用来表示本地计算机，并且默认被解析到 127.0.0.1 这个地址.

但是你只要修改主机文件（hosts），就可以把 localhost 解析到其他地址，跟域名解析类似.

而 127.0.0.1 是 IPv4 的一个特殊的 **IP 地址**，直接指向本地回环接口，用于在本地进行网络通信.

为了兼容 IPv4 和 IPv6，我们访问 localhost 时，操作系统会首先尝试解析 IPv6 的回环地址 `::1`​ . 如果系统不支持 IPv6，或者无法解析为 IPv6 地址，才会继续解析为 IPv4 的回环地址 127.0.0.1.

而直接访问 127.0.0.1 时，系统会默认解析到 IPv4 的回环接口. 这才导致输入这两个地址时，使用的服务 / 访问到的内容不一样.

‍

‍

‍

# 八股整合

‍
