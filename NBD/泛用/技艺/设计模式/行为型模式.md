‍

‍

# 知识

‍

主要涉及算法和对象间的职责分配. 通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务. 

‍

* 责任链
* 命令
* 解释器
* 迭代器
* 中介
* 备忘录
* 观察者
* 状态
* 策略
* 模板方法
* 访问者

‍

‍

‍

# 类型

‍

‍

‍

## 责任链

‍

职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止. 职责链模式是一种对象行为型模式

职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求. 链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦

核心在于引入了一个抽象处理者

‍

### 结构

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/47cf0039e3483a068897ae9d73a82304.gif)​

‍

● Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法. 因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用. 通过该引用，处理者可以连成一条链. 

● ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发. 

‍

### 实现

‍

#### 抽象处理者

```java
abstract class Handler {  
    //维持对下家的引用  
protected Handler successor;  
    public void setSuccessor(Handler successor) {  
        this.successor=successor;  
    }  
    public abstract void handleRequest(String request);  
}
```

定义了对下家的引用对象

‍

#### 具体处理者

抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家

‍

```java
class ConcreteHandler extends Handler {  
    public void handleRequest(String request) {  
        if (请求满足条件) {  
            //处理请求  
        }  
        else {  
            this.successor.handleRequest(request);  //转发请求  
        }  
    }  
}
```

‍

‍

### 评价

‍

#### 优点

(1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度. 

(2) 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接. 

(3) 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责. 

(4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的. 

‍

#### 缺点

(1) 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理. 

(2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便. 

(3) 如果建链不当，可能会造成循环调用，将导致系统陷入死循环. 

‍

‍

### 场景

(1) 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的. 

(2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求. 

(3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序. 

‍

‍

### 拓展

‍

#### 纯的职责链模式

一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况. 而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况. 

‍

#### 不纯的职责链模式

一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收. 

‍

#### 与其他模式关系

‍

* 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：  

  * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理.
  * 命令在发送者和请求者之间建立单向连接.
  * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通.
  * 观察者允许接收者动态地订阅或取消接收请求.
* 责任链通常和组合模式结合使用.  在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部.
* 责任链的管理者可使用命令模式实现.  在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作.   

  还有另外一种实现方式， 那就是请求自身就是一个命令对象.  在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作.
* 责任链和装饰模式的类结构非常相似.  两者都依赖递归组合将需要执行的操作传递给一系列对象.  但是， 两者有几点重要的不同之处.   

  责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求.  另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为.  此外， 装饰无法中断请求的传递.

‍

‍

‍

## 命令

命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作. 命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式

带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度

‍

‍

### 结构

核心在于引入了命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/e5e6593008d255f207da4c0d7a8c200a.jpg)​

‍

● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作. 

● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中. 在实现execute()方法时，将调用接收者对象的相关操作(Action). 

● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求. 一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系. 在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作. 

● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理. 

‍

### 实现

命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开. 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作. 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的

‍

‍

‍

#### 抽象命令类

关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联. 在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法. 

```java
abstract class Command {  
    public abstract void execute();  
}
```

‍

‍

#### 调用者

将针对抽象命令类进行编程，可以通过构造注入或者设值注入的方式在运行时传入具体命令类对象，并在业务方法中调用命令对象的execute()方法

```java
class Invoker {  
    private Command command;  
    //构造注入  
    public Invoker(Command command) {  
        this.command = command;  
    }  
    //设值注入  
    public void setCommand(Command command) {  
        this.command = command;  
    }  
    //业务方法，用于调用命令类的execute()方法  
    public void call() {  
        command.execute();  
    }  
}
```

‍

#### 具体命令类

继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法action()

‍

```java
class ConcreteCommand extends Command {  
    private Receiver receiver; //维持一个对请求接收者对象的引用  
    public void execute() {  
        receiver.action(); //调用请求接收者的业务处理方法action()  
    }  
}
```

‍

#### 请求接收者

具体实现对请求的业务处理，它提供了action()方法，用于执行与请求相关的操作

```java
class Receiver {  
    public void action() {  
        //具体操作  
    }  
}
```

‍

### 评价

‍

#### 优点

(1) 降低系统的耦合度. 由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性. 

(2) 新的命令可以很容易地加入到系统中. 由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求. 

(3) 可以比较容易地设计一个命令队列或宏命令（组合命令）. 

(4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案. 

‍

#### 缺点

使用命令模式可能会导致某些系统有过多的具体命令类. 因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用. 

‍

‍

### 场景

(1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互. 请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用. 

(2) 系统需要在不同的时间指定请求、将请求排队和执行请求. 一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现. 

(3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作. 

(4) 系统需要将一组操作组合在一起形成宏命令. 

‍

### 拓展

‍

#### 与其他模式关系

* 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：  

  * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理.
  * 命令在发送者和请求者之间建立单向连接.
  * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通.
  * 观察者允许接收者动态地订阅或取消接收请求.
* 责任链的管理者可使用命令模式实现.  在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作.   

  还有另外一种实现方式， 那就是请求自身就是一个命令对象.  在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作.
* 你可以同时使用命令和备忘录模式来实现 “撤销”.  在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态.
* 命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象.  但是， 它们的意图有非常大的不同.   

  * 你可以使用命令来将任何操作转换为对象.  操作的参数将成为对象的成员变量.  你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等.
  * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法.
* 原型模式可用于保存命令的历史记录.
* 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作.

‍

‍

## 解释器

解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码. 解释器模式是一种类行为型模式. 

解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器. 在某些情况下，为了更好地描述某一些特定类型的问题，我们可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应为该语言中的句子. 此时，可以使用解释器模式来设计这种新的语言. 对解释器模式的学习能够加深我们对面向对象思想的理解，并且掌握编程语言中文法规则的解释过程. 

‍

### 结构

​![](https://static.sitestack.cn/projects/design-pattern-java/be061f99c10d88dda7acee81df3b3f66.jpg)​

‍

● AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类. 

● TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例. 通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子. 

● NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成. 

● Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句. 

‍

### 实现

‍

#### 抽象表达式类

每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统将具有较好的灵活性和可扩展性. 对于所有的终结符和非终结符，我们首先需要抽象出一个公共父类，即抽象表达式类

```java
abstract class AbstractExpression {
       public  abstract void interpret(Context ctx);
}
```

‍

#### 终结符表达式

终结符表达式和非终结符表达式类都是抽象表达式类的子类，对于终结符表达式，其代码很简单，主要是对终结符元素的处理

```java
class TerminalExpression extends  AbstractExpression {
       public  void interpret(Context ctx) {
              //终结符表达式的解释操作
       }
}
```

‍

#### 非终结符表达式

可以通过非终结符将表达式组合成更加复杂的结构，对于包含两个操作元素的非终结符表达式类，其典型代码

```java
class NonterminalExpression extends  AbstractExpression {
       private  AbstractExpression left;
       private  AbstractExpression right;
       public  NonterminalExpression(AbstractExpression left,AbstractExpression right) {
              this.left=left;
              this.right=right;
       }
       public void interpret(Context ctx) {
              //递归调用每一个组成部分的interpret()方法
              //在递归调用时指定组成部分的连接方式，即非终结符的功能
       }   
}
```

‍

#### 环境类

用于存储一些全局信息; 当系统无须提供全局公共信息时可以省略环境类

```java
class Context {
     private HashMap map = new HashMap();
     public void assign(String key, String value) {
         //往环境类中设值
     }
public String  lookup(String key) {
         //获取存储在环境类中的值
     }
}
```

‍

### 评价

难度较大、使用频率较低

‍

#### 优点

(1) 易于改变和扩展文法. 由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法. 

(2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言. 

(3) 实现文法较为容易. 在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码. 

(4) 增加新的解释表达式较为方便. 如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”. 

‍

#### 缺点

(1) 对于复杂文法难以维护. 在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式. 

(2) 执行效率较低. 由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦. 

‍

### 场景

(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树. 

(2) 一些重复出现的问题可以用一种简单的语言来进行表达. 

(3) 一个语言的文法较为简单. 

(4) 执行效率不是关键问题. 【注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高. 】

‍

‍

‍

## 迭代器

迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor). 迭代器模式是一种对象行为型模式. 

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

‍

### 结构

在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式

‍

​![](https://th.bing.com/th/id/R.0d52c2afc9ed698a31c7bf03c29283cf?rik=BD%2f870Nro0Id6w&pid=ImgRaw&r=0)​

‍

● Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法. 

● ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数. 

● Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色. 

● ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例. 

在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有. 迭代器的引入，将使得对一个复杂聚合对象的操作变得简单. 

‍

### 实现

‍

#### 抽象迭代器

```java
interface Iterator {  
    public void first(); //将游标指向第一个元素  
    public void next(); //将游标指向下一个元素  
    public boolean hasNext(); //判断是否存在下一个元素  
    public Object currentItem(); //获取游标指向的当前元素  
}
```

‍

‍

#### 具体迭代器

实现抽象迭代器声明的遍历数据的方法

```java
class ConcreteIterator implements Iterator {  
    private ConcreteAggregate objects; //维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据  
    private int cursor; //定义一个游标，用于记录当前访问位置  
    public ConcreteIterator(ConcreteAggregate objects) {  
        this.objects=objects;  
    }  
    public void first() {  ......  }  
    public void next() {  ......  }  
    public boolean hasNext() {  ......  }  
    public Object currentItem() {  ......  }  
}
```

‍

‍

#### 聚合类

存储数据并负责创建迭代器对象

```java
interface Aggregate {  
    Iterator createIterator();  
}
```

‍

‍

#### 具体聚合类

作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法createIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象

```java
class ConcreteAggregate implements Aggregate {  
    ......  
    public Iterator createIterator() {  
    return new ConcreteIterator(this);  
    }  
    ......  
}
```

‍

### 评价

迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成. 由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一. 

‍

#### 优点

(1) 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式. 在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式. 

(2) 迭代器简化了聚合类. 由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计. 

(3) 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求. 

‍

#### 缺点

(1) 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性. 

(2) 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象. 在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情. 

‍

### 场景

(1) 访问一个聚合对象的内容而无须暴露它的内部表示. 将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节. 

(2) 需要为一个聚合对象提供多种遍历方式. 

(3) 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口. 

‍

### 拓展

内部类迭代器

JDK内置迭代器

‍

‍

#### 与其他模式关系

* 你可以使用迭代器模式来遍历组合模式树.
* 你可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配.
* 你可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚.
* 可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同.

‍

## 中介者

中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互. 中介者模式又称为调停者模式，它是一种对象行为型模式. 

它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合. 一个多方会谈，逻辑写起来很复杂, 引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了

‍

### 结构

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/77bf6ed83831b3c822a3cb02410a9abf.jpg)​

● Mediator（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信. 

● ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用. 

● Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信. 

● ConcreteColleague（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法. 

‍

中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责：

(1) 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用. 该中转作用属于中介者在结构上的支持. 

(2) 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装. 该协调作用属于中介者在行为上的支持. 

‍

‍

### 实现

‍

‍

#### 抽象中介者

‍

```java
abstract class Mediator {  
    protected ArrayList<Colleague> colleagues; //用于存储同事对象  

    //注册方法，用于增加同事对象  
    public void register(Colleague colleague) {  
        colleagues.add(colleague);  
    }  

    //声明抽象的业务方法  
    public abstract void operation();  
}  


```

‍

#### 具体中介者

```java
class ConcreteMediator extends Mediator {  
    //实现业务方法，封装同事之间的调用  
    public void operation() {  
        ......  
        ((Colleague)(colleagues.get(0))).method1(); //通过中介者调用同事类的方法  
        ......  
    }  
}
```

‍

#### 抽象同事类

```java
abstract class Colleague {  

    protected Mediator mediator; //维持一个抽象中介者的引用 
 
    public Colleague(Mediator mediator) {  
        this.mediator=mediator;  
    }  

    public abstract void method1(); //声明自身方法，处理自己的行为 
 
    //定义依赖方法，与中介者进行通信  
    public void method2() {  
        mediator.operation();  
    }  
}
```

‍

‍

#### 具体同事类

```java
class ConcreteColleague extends Colleague {  
    public ConcreteColleague(Mediator mediator) {  
        super(mediator);  
    }  
    //实现自身方法  
    public void method1() {  
        ......  
    }  
}
```

在具体同事类ConcreteColleague中实现了在抽象同事类中声明的方法，其中方法method1()是同事类的自身方法(Self-Method)，用于处理自己的行为，而方法method2()是依赖方法(Depend-Method)，用于调用在中介者中定义的方法，依赖中介者来完成相应的行为，例如调用另一个同事类的相关方法. 

‍

### 评价

中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系. 中介者模式在事件驱动类软件中应用较为广泛，特别是基于GUI（Graphical User Interface，图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用. 

‍

#### 优点

(1) 中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构. 

(2) 中介者模式可将各同事对象解耦. 中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”. 

(3) 可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展. 

‍

#### 缺点

在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护. 

‍

### 场景

(1) 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解. 

(2) 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象. 

(3) 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类. 可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类. 

‍

### 拓展

#### 与其他模式关系

* 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：

  * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理.
  * 命令在发送者和请求者之间建立单向连接.
  * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通.
  * 观察者允许接收者动态地订阅或取消接收请求.
* 外观模式和中介者的职责类似 **：**  它们都尝试在大量紧密耦合的类中组织起合作 **. **

  * 外观为子系统中的所有对象定义了一个简单接口 **，**  但是它不提供任何新功能 **. **  子系统本身不会意识到外观的存在 **. **  子系统中的对象可以直接进行交流 **. **
  * 中介者将系统中组件的沟通行为中心化 **. **  各组件只知道中介者对象 **，**  无法直接相互交流 **. **
* 中介者和观察者之间的区别往往很难记住 **. **  在大部分情况下 **，**  你可以使用其中一种模式 **，**  而有时可以同时使用 **. **  让我们来看看如何做到这一点 **. **   
  中介者的主要目标是消除一系列系统组件之间的相互依赖.  这些组件将依赖于同一个中介者对象.  观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用 **. **   
  有一种流行的中介者模式实现方式依赖于观察者.  中介者对象担当发布者的角色 **，**  其他组件则作为订阅者 **，**  可以订阅中介者的事件或取消订阅 **. **  当*中*介者以这种方式实现时， 它可能看上去与观察者非常相似.   
  当你感到疑惑时， 记住可以采用其他方式来实现中介者.  例如， 你可永久性地将所有组件链接到同一个中介者对象.  这种实现方式和观察者并不相同， 但这仍是一种中介者模式.   
  假设有一个程序 **，**  其所有的组件都变成了发布者 **，**  它们之间可以相互建立动态连接 **. **  这样程序中就没有中心化的中介者对象 **，**  而只有一些分布式的观察者 **. **

‍

## 备忘录 

备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态. 它是一种对象行为型模式，其别名为Token. 其储存系统关键对象的重要状态, 维护关键对象的封装这个专门掌握状态的对象，就称为备忘录.   

‍

### 结构

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/71a36d1ce3200f6337c40f8b54fff3ca.jpg)​

‍

● Originator（原发器）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器. 

● Memento（备忘录)：存储原发器的内部状态，根据原发器来决定保存哪些内部状态. 备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性. 需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同. 

● Caretaker（负责人）：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查. 在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节. 

‍

‍

### 实现

‍

关键在于如何设计备忘录类和负责人类. 由于在备忘录中存储的是原发器的中间状态，因此需要防止原发器以外的其他对象访问备忘录，特别是不允许其他对象来修改备忘录. 

‍

#### 原发器

```java
package dp.memento;  
public class Originator {  
    private String state;  
    public Originator(){}  
　　// 创建一个备忘录对象  
    public Memento createMemento() {  
　　　　return new Memento(this);  
    }  
　　// 根据备忘录对象恢复原发器状态  
    public void restoreMemento(Memento m) {  
　　　　 state = m.state;  
    }  
    public void setState(String state) {  
        this.state=state;  
    }  
    public String getState() {  
        return this.state;  
    }  
}
```

‍

#### 备忘录

通常提供了与原发器相对应的属性（可以是全部，也可以是部分）用于存储原发器的状态

```java
package dp.memento;  
//备忘录类，默认可见性，包内可见  
class Memento {  
    private String state;  

    public Memento(Originator o) {  
　　　　state = o.getState();  
    }  

    public void setState(String state) {  
        this.state=state;  
    }  

    public String getState() {  
        return this.state;  
    }  
}
```

‍

#### 负责人

保存备忘录对象，并提供getMemento()方法用于向客户端返回一个备忘录对象，原发器通过使用这个备忘录对象可以回到某个历史状态

```java
package dp.memento;  
public class Caretaker {  
    private Memento memento;  
    public Memento getMemento() {  
        return memento;  
    }  
    public void setMemento(Memento memento) {  
        this.memento=memento;  
    }  
}
```

在Caretaker类中不应该直接调用Memento中的状态改变方法，它的作用仅仅用于存储备忘录对象. 将原发器备份生成的备忘录对象存储在其中，当用户需要对原发器进行恢复时再将存储在其中的备忘录对象取出. 

‍

### 拓展

‍

#### 多次撤销

定义了一个ArrayList类型的集合对象来存储多个备忘录

‍

#### 封装特点

备忘录是一个很特殊的对象，只有原发器对它拥有控制的权力，负责人只负责管理，而其他类无法访问到备忘录，因此我们需要对备忘录进行封装. 

为了实现对备忘录对象的封装，需要对备忘录的调用进行控制，对于原发器而言，它可以调用备忘录的所有信息，允许原发器访问返回到先前状态所需的所有数据；对于负责人而言，只负责备忘录的保存并将备忘录传递给其他对象；对于其他对象而言，只需要从负责人处取出备忘录对象并将原发器对象的状态恢复，而无须关心备忘录的保存细节. 理想的情况是只允许生成该备忘录的那个原发器访问备忘录的内部状态. 

在实际开发中，原发器与备忘录之间的关系是非常特殊的，它们要分享信息而不让其他类知道，实现的方法因编程语言的不同而有所差异，在C++中可以使用friend关键字，让原发器类和备忘录类成为友元类，互相之间可以访问对象的一些私有的属性；在Java语言中可以将原发器类和备忘录类放在一个包中，让它们之间满足默认的包内可见性，也可以将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据，其他对象都无法使用备忘录中的数据. 

‍

#### Java内部类实现备忘录模式

‍

### 评价

备忘录模式在很多软件的使用过程中普遍存在，但是在应用软件开发中，它的使用频率并不太高，因为现在很多基于窗体和浏览器的应用软件并没有提供撤销操作. 如果需要为软件提供撤销功能，备忘录模式无疑是一种很好的解决方案. 在一些字处理软件、图像编辑软件、数据库管理系统等软件中备忘录模式都得到了很好的应用. 

‍

#### 优点

(1)它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原. 

(2)备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动. 备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作. 

‍

#### 缺点

资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源. 

‍

### 场景

(1)保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作. 

(2)防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象. 

‍

### 拓展

‍

‍

#### 与其他模式关系

* 你可以同时使用命令模式和备忘录模式来实现 “撤销”.  在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态.
* 你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态， 并且在需要的时候进行回滚.
* 有时候原型模式可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建.

‍

## 观察者

观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新. 观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式. 观察者模式是一种对象行为型模式. 

观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应. 在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展. 

‍

### 结构

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/c28fcbfcd820c44ba2226059c0ebaaab.jpg)​

‍

‍

● Subject（目标）：目标又称为主题，它是指被观察的对象. 在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify(). 目标类可以是接口，也可以是抽象类或具体类. 

● ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）. 如果无须扩展目标类，则具体目标类可以省略. 

● Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者. 

● ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法. 通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除. 

‍

‍

### 实现

‍

#### 抽象目标

观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知

```java
import java.util.*;  
abstract class Subject { 

    //定义一个观察者集合用于存储所有观察者对象  
    protected ArrayList observers<Observer> = new ArrayList();  

    //注册方法，用于向观察者集合中增加一个观察者  
    public void attach(Observer observer) {  
        observers.add(observer);  
    }  

    //注销方法，用于在观察者集合中删除一个观察者  
    public void detach(Observer observer) {  
        observers.remove(observer);  
    }  
  
    //声明抽象通知方法  
    public abstract void notify();  

    }  
```

‍

#### 具体目标

```java
class ConcreteSubject extends Subject {  
        //实现通知方法  
        public void notify() {  
            //遍历观察者集合，调用每一个观察者的响应方法  
            for(Object obs:observers) {  
                ((Observer)obs).update();  
        }  
    }   
}
```

‍

#### 抽象观察者

```java
interface Observer {  
    //声明响应方法  
    public void update();  
}
```

‍

#### 具体观察者

```java
class ConcreteObserver implements Observer {  
    //实现响应方法  
    public void update() {  
        //具体响应代码  
    }  
}
```

‍

### 评价

观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式. 观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术（如SAX2）以及Web事件处理中也都使用了观察者模式. 

‍

#### 优点

(1) 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色. 

(2) 观察者模式在观察目标和观察者之间建立一个抽象的耦合. 观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者. 由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次. 

(3) 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度. 

(4) 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便. 

‍

#### 缺点

(1) 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间. 

(2) 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃. 

(3) 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化. 

‍

### 场景

(1) 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用. 

(2) 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁. 

(3) 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制. 

‍

‍

### 拓展

‍

#### JDK支持

观察者模式在Java语言中的地位非常重要. 在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了JDK对观察者模式的支持

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/0801a8bbc4c768f754f2df383db2687a.jpg "JDK提供的Observable类及Observer接口结构图")​

(1) Observer接口

在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码

​`void  update(Observable o, Object arg);`​

当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为. 当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法. 

‍

(2) Observable类

java.util.Observable类充当观察目标类，在Observable中定义了一个向量Vector来存储观察者对象，它所包含的方法及说明

‍

|方法名|方法描述|
| ------------------------------------------------| --------------------------------------------------------------------------------------------------------------------|
|Observable()|构造方法，实例化Vector向量. |
|addObserver(Observer o)|用于注册新的观察者对象到向量中. |
|deleteObserver (Observer o)|用于删除向量中的某一个观察者对象. |
|notifyObservers()和notifyObservers(Object arg)|通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法. |
|deleteObservers()|用于清空向量，即删除向量中所有观察者对象. |
|setChanged()|该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化. |
|clearChanged()|用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法. |
|hasChanged()|用于测试对象状态是否改变. |
|countObservers()|用于返回向量中观察者的数量. |

可以直接使用Observer接口和Observable类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类，通过使用JDK中的Observer接口和Observable类，可以更加方便地在Java语言中应用观察者模式

‍

#### Java事件处理模型

[Link](https://www.bookstack.cn/read/design-pattern-java/%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E8%81%94%E5%8A%A8%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89.md) 略

‍

#### 观察者模式与MVC

略

‍

‍

#### 与其他模式关系

* 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式 **：**

  * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理.
  * 命令在发送者和请求​者之间建立单向连接.
  * ​中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通.
  * 观察者允许接收者动态地订阅或取消接收请求.
* 中介者和观察者之间的区别往往很难记住.  在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用.  让我们来看看如何做到这一点.   
  中介者的主要目标是消除一系列系统组件之间的相互依赖.  这些组件将依赖于同一个中介者对象.  观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用.   
  有一种流行的中介者模式实现方式依赖于观察者.  中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅.  当中介者以这种方式实现时， 它可能看上去与观察者非常相似.   
  当你感到疑惑时， 记住可以采用其他方式来实现中介者.  例如， 你可永久性地将所有组件链接到同一个中介者对象.  这种实现方式和观察者并不相同， 但这仍是一种中介者模式.   
  假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接.  这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者.

‍

‍

## 状态

状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类. 其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式. 

它允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类. 将状态封装成为独立的类，并将动作委托到代表当前状态的对象，我们知道行为会随着内部状态而改变. 经常用在带有状态的对象中

‍

### 结构

状态模式中引入了抽象状态类和具体状态类，它们是状态模式的核心

​![](https://static.sitestack.cn/projects/design-pattern-java/a54c3c0f36bc292a4dc8ae58d7b063de.jpg)​

‍

● Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象. 由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类. 在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象. 

● State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中. 

● ConcreteState（具体状态类）：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同. 

‍

‍

‍

### 实现

‍

#### 抽象状态

```java
abstract class State {  
    //声明抽象业务方法，不同的具体状态类可以不同的实现  
    public abstract void handle();  
}
```

‍

#### 具体状态

```java
class ConcreteState extends State {  
    public void handle() {  
        //方法具体实现代码  
    }  
}
```

‍

#### 环境

维持一个对抽象状态类的引用，通过setState()方法可以向环境类注入不同的状态对象，再在环境类的业务方法中调用状态对象的方法

```java
class Context {  
    private State state; //维持一个对抽象状态对象的引用  
    private int value; //其他属性值，该属性值的变化可能会导致对象状态发生变化  
    //设置状态对象  
    public void setState(State state) {  
        this.state = state;  
    }  
    public void request() {  
        //其他代码  
        state.handle(); //调用状态对象的业务方法  
        //其他代码  
    }  
}
```

环境类实际上是真正拥有状态的对象，我们只是将环境类中与状态有关的代码提取出来封装到专门的状态类中. 在状态模式结构图中，环境类Context与抽象状态类State之间存在单向关联关系，在Context中定义了一个State对象. 在实际使用时，它们之间可能存在更为复杂的关系，State与Context之间可能也存在依赖或者关联关系. 

‍

### 类型

在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式

‍

#### 统一由环境类来负责

此时，环境类还充当了状态管理器(State Manager)角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，还可以提供一个专门的方法用于实现属性判断和状态转换

```java
……  
     public void changeState() {  
    //判断属性值，根据属性值进行状态转换  
     if (value == 0) {  
        this.setState(new ConcreteStateA());  
    }  
    else if (value == 1) {  
        this.setState(new ConcreteStateB());  
    }  
       ......  
}  
   ……
```

‍

‍

#### 由具体状态类来负责

可以在具体状态类的业务方法中判断环境类的某些属性值再根据情况为环境类设置新的状态对象，实现状态转换，同样，也可以提供一个专门的方法来负责属性值的判断和状态转换. 此时，状态类与环境类之间就将存在依赖或关联关系，因为状态类需要访问环境类中的属性值

```java
……  
     public void changeState(Context ctx) {  
    //根据环境对象中的属性值进行状态转换  
     if (ctx.getValue() == 1) {  
        ctx.setState(new ConcreteStateB());  
    }  
    else if (ctx.getValue() == 2) {  
        ctx.setState(new ConcreteStateC());  
    }  
       ......  
}  
   ……
```

‍

### 评价

‍

状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用. 在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等. 

‍

#### 优点

(1) 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中. 

(2) 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为. 

(3) 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起. 

(4) 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数. 

‍

#### 缺点

(1) 状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大. 

(2) 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度. 

(3) 状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码. 

‍

‍

### 场景

(1) 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化. 

(2) 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强. 

‍

‍

### 拓展

‍

#### 状态模式和策略模式差别

状态模式和策略模式有相同的类图，但是他们的差别:

> 以策略模式而言，客户通常主动指定Context所要组合的策略对象是哪一个. 现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个context对象来说，通常都只有一个最适当的策略对象. 比方说，在第1章，有些鸭子（例如绿头鸭）被设置成利用典型的飞翔行为进行飞翔，而有些鸭子（例如橡皮鸭和诱饵鸭）使用的飞翔行为只能让他们紧贴地面. 
>
> 一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案. 如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难. 有了策略模式，你可以通过组合不同的对象来改变行为. 
>
> 我们把状态模式想成是不用在context中放置许多条件判断的替代方案. 通过将行为包装进状态对象中，你可以通过在context内简单地改变状态对象来改变context的行为.

‍

#### 共享状态

在有些情况下，多个环境对象可能需要共享同一个状态，如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象

‍

#### 使用环境类实现状态转换

在状态模式中实现状态转换时，具体状态类可通过调用环境类Context的setState()方法进行状态的转换操作，也可以统一由环境类Context来实现状态的转换. 此时，增加新的具体状态类可能需要修改其他具体状态类或者环境类的源代码，否则系统无法转换到新增状态. 但是对于客户端来说，无须关心状态类，可以为环境类设置默认的状态类，而将状态的转换工作交给具体状态类或环境类来完成，具体的转换细节对于客户端而言是透明的. 

‍

‍

#### 与其他模式关系

* 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似.  实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题.  模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题.
* 状态可被视为策略的扩展.  两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为.  策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在.  但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态.

‍

‍

## 策略

策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy). 策略模式是一种对象行为型模式. 

策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”. 在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可. 

策略模式定义算法族, 分别封装, 让其之间可以互相替换, 使得算法的变化独立于使用算法的用户, 客户使用封装好的方法族, 而不是要自己去编写实例重载

定义一组算法，并把其封装到一个对象中. 然后在运行时，可以灵活的使用其中的一个算法

‍

### 结构

​![](https://static.sitestack.cn/projects/design-pattern-java/1ff476a086570c5415f1a9cba65f87ab.jpg)​

‍

● Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略. 在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略. 

● Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口. 环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法. 

● ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理. 

‍

策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理. 策略模式通常把一个系列的算法封装到一系列具体策略类里面，作为抽象策略类的子类. 在策略模式中，对环境类和抽象策略类的理解非常重要，环境类是需要使用算法的类. 在一个系统中可以存在多个环境类，它们可能需要重用一些相同的算法. 

‍

‍

### 实现

‍

#### 抽象策略

```java
abstract class AbstractStrategy {  
    public abstract void algorithm(); //声明抽象算法  
}
```

‍

#### 具体算法

```java
class ConcreteStrategyA extends AbstractStrategy {  
    //算法的具体实现  
    public void algorithm() {  
       //算法A  
    }  
}
```

‍

#### Context

在Context类中定义一个AbstractStrategy类型的对象strategy，通过注入的方式在客户端传入一个具体策略对象

```java
class Context {  
private AbstractStrategy strategy; //维持一个对抽象策略类的引用  
    public void setStrategy(AbstractStrategy strategy) {  
        this.strategy= strategy;  
    }  

    //调用策略类中的算法  
    public void algorithm() {  
        strategy.algorithm();  
    }  
}
```

‍

#### 客户端

客户端代码中只需注入一个具体策略对象，可以将具体策略类类名存储在配置文件中，通过反射来动态创建具体策略对象，从而使得用户可以灵活地更换具体策略类，增加新的具体策略类也很方便. 策略模式提供了一种可插入式(Pluggable)算法的实现方案

```java
……  
Context context = new Context();  
AbstractStrategy strategy;  
strategy = new ConcreteStrategyA(); //可在运行时指定类型  
context.setStrategy(strategy);  
context.algorithm();  
……
```

‍

### 评价

策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一. 策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法. 只要涉及到算法的封装、复用和切换都可以考虑使用策略模式. 

‍

#### 优点

(1) 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为. 

(2) 策略模式提供了管理相关的算法族的办法. 策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码. 

(3) 策略模式提供了一种可以替换继承关系的办法. 如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法. 但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换. 

(4) 使用策略模式可以避免多重条件选择语句. 多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后. 

(5) 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类. 

‍

#### 缺点

(1) 客户端必须知道所有的策略类，并自行决定使用哪一个策略类. 这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法. 换言之，策略模式只适用于客户端知道所有的算法或行为的情况. 

(2) 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类. 

(3) 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况. 

‍

‍

### 场景

(1) 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类. 换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象. 

(2) 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现. 此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句. 

(3) 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性. 

‍

### 拓展

‍

#### 实现Tips

‍

* 找出会变化的部分,并把它们和不变的分开
* 针对接口编程而不是实现
* 多用组合,少用继承; 根据java不支持多继承以及接口的可复用性

核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑

‍

‍

#### 与其他模式关系

‍

* 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似 **. **  实际上 **，**  它们都基于**组合模式**——即将工作委派给其他对象 **，**  不过也各自解决了不同的问题.  模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题 **. **
* 命令模式和策略看上去很像， 因为两者都能通过某些行为来参数化对象.  但是， 它们的意图有非常大的不同. 

  * 你可以使用命令来将任何操作转换为对象.  操作的参数将成为对象的成员变量.  你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等.
  * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法.
* 装饰模式可让你更改对​象的外表， 策略则让你能够改变其本质.
* 模板方法模式基于继承机制 **：**  它允许你通过扩展子类中的部分内容来改变部分算法 **. **  策略基于组合机制 **：**  你可以通过对相应行为提供不同的策略来改变对象的部分行为.  模板方法在类层次上运作， 因此它是静态的.  策略在对象层次上运作， 因此允许在运行时切换行为.
* 状态可被视为策略的扩展 **. **  两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为.  策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在.  但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态.

‍

‍

## 模板

模板方法模式(Template Method Pattern)：定义一个操作中算法的框架，而将一些步骤延迟到子类中. 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤. 基于继承的代码复用技术，它是一种类行为型模式. 

是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系. 通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果. 模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成. 

‍

### 结构

核心是抽象类和其中的模板方法的设计

‍

(1) AbstractClass（抽象类）：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤. 同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法. 

(2) ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作. 

‍

### 实现

‍

#### 模板方法

一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法. 这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来. 模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法. 由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口. 

‍

#### 基本方法

基本方法是实现算法各个步骤的方法，是模板方法的组成部分. 

基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method). 

‍

(1) 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现. 在C#语言里一个抽象方法以abstract关键字标识. 

(2) 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承. 

(3) 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展. 通常在父类中给出的实现是一个空实现（可使用virtual关键字将其定义为虚函数），并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现. 

‍

##### 两类钩子方法

第一类钩子方法可以与一些具体步骤“挂钩”，以实现在不同条件下执行模板方法中的不同步骤，这类钩子方法的返回类型通常是bool类型的，这类方法名一般为IsXXX()，用于对某个条件进行判断，如果条件满足则执行某一步骤，否则将不执行

‍

还有一类钩子方法就是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法，与抽象方法相比，这类钩子方法的好处在于子类如果没有覆盖父类中定义的钩子方法，编译可以正常通过，但是如果没有覆盖父类中声明的抽象方法，编译将报错. 

在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制. 

‍

### 评价

模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式. 模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）

‍

#### 优点

(1) 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序. 

(2) 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用. 

(3) 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行. 

(4) 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则. 

‍

#### 缺点

需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计. 

‍

### 场景

(1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现. 即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现. 

(2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复. 

(3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制. 

‍

### 拓展

‍

#### **Tips**

* 为了防止子类改变模板方法中的算法，可以将模板方法声明为final
* 工厂方法是模板方法的一种特殊版本
* hook()钩子方法    什么都不做=可选的扩展功能, 可以在子类看情况里覆盖, 或者用于监测

‍

#### 与其他模式关系

* 工厂方法模式是模板方法模式的一种特殊形式.  同时， 工厂方法可以作为一个大型模板方法中的一个步骤.
* 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法.  策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为.  模板方法在类层次上运作， 因此它是静态的.  策略在对象层次上运作， 因此允许在运行时切换行为.

‍

## 访问者

访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作. 访问者模式是一种对象行为型模式. 

访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问. 访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素. 相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问. 在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性. 

‍

‍

### 结构

‍

​![](https://static.sitestack.cn/projects/design-pattern-java/59651b996a63070d67890a17ea6ece9d.gif)​

‍

●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作. 

●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素. 

●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数. 【稍后将介绍为什么要这样设计. 】

●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作. 

● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法. 它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象. 

‍

### 实现

‍

#### 抽象访问者

‍

在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法. 这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如visitElementA(ElementA elementA)，还有一种是统一取名为visit()，通过参数类型的不同来定义一系列重载的visit()方法. 当然，如果所有的访问者对某一类型的元素的访问操作都相同，则可以将操作代码移到抽象访问者类中

```java
abstract class Visitor  
{  
    public abstract void visit(ConcreteElementA elementA);  
    public abstract void visit(ConcreteElementB elementB);  
    public void visit(ConcreteElementC elementC)  
    {  
        //元素ConcreteElementC操作代码  
    }  
}
```

‍

#### 具体访问者

使用了重载visit()方法的方式来定义多个方法用于操作不同类型的元素对象. 在抽象访问者Visitor类的子类ConcreteVisitor中实现了抽象的访问方法，用于定义对不同类型元素对象的操作

```java
class ConcreteVisitor extends Visitor  
{  
    public void visit(ConcreteElementA elementA)  
    {  
        //元素ConcreteElementA操作代码  
    }  
    public void visit(ConcreteElementB elementB)  
    {  
        //元素ConcreteElementB操作代码  
    }  
}
```

‍

#### 元素

定义了一个accept()方法，用于接受访问者的访问

需要注意的是该方法传入了一个抽象访问者Visitor类型的参数，即针对抽象访问者进行编程，而不是具体访问者，在程序运行时再确定具体访问者的类型，并调用具体访问者对象的visit()方法实现对元素对象的操作. 在抽象元素类Element的子类中实现了accept()方法，用于接受访问者的访问，

```java
interface Element  
{  
    public void accept(Visitor visitor);  
}
```

‍

#### 具体元素类

```java
class ConcreteElementA implements Element  
{  
    public void accept(Visitor visitor)  
    {  
        visitor.visit(this);  
    }  
    public void operationA()  
    {  
        //业务方法  
    }  
}
```

在具体元素类ConcreteElementA的accept()方法中，通过调用Visitor类的visit()方法实现对元素的访问，并以当前对象作为visit()方法的参数. 其具体执行过程如下：

(1) 调用具体元素类的accept(Visitor visitor)方法，并将Visitor子类对象作为其参数；

(2) 在具体元素类accept(Visitor visitor)方法内部调用传入的Visitor对象的visit()方法，如visit(ConcreteElementA elementA)，将当前具体元素类对象(this)作为参数，如visitor.visit(this)；

(3) 执行Visitor对象的visit()方法，在其中还可以调用具体元素对象的业务方法. 

这种调用机制也称为“双重分派”，正因为使用了双重分派机制，使得增加新的访问者无须修改现有类库代码，只需将新的访问者对象作为参数传入具体元素对象的accept()方法，程序运行时将回调在新增Visitor类中定义的visit()方法，从而增加新的元素访问方式. 

‍

#### 对象结构

是一个集合，它用于存储元素对象并接受访问者的访问

```java
class ObjectStructure  
{  
    private ArrayList<Element> list = new ArrayList<Element>(); //定义一个集合用于存储元素对象  
    public void accept(Visitor visitor)  
    {  
        Iterator i=list.iterator();  
        while(i.hasNext())  
        {  
            ((Element)i.next()).accept(visitor); //遍历访问集合中的每一个元素  
        }  
    }  
    public void addElement(Element element)  
    {  
        list.add(element);  
    }  
    public void removeElement(Element element)  
    {  
        list.remove(element);  
    }  
}
```

在对象结构中可以使用迭代器对存储在集合中的元素对象进行遍历，并逐个调用每一个对象的accept()方法，实现对元素对象的访问操作. 

‍

### 评价

由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高. 当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计. 在XML文档解析、编译器的设计、复杂集合对象的处理等领域访问者模式得到了一定的应用. 

‍

#### 优点

(1) 增加新的访问操作很方便. 使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”. 

(2) 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中. 类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问. 

(3) 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作. 

‍

#### 缺点

(1) 增加新的元素类很困难. 在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求. 

(2) 破坏封装. 访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问. 

‍

‍

### 场景

(1) 一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作. 在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作. 

(2) 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类. 访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离. 

(3) 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作. 

‍

‍

### 拓展

‍

#### 与其他模式关系

‍

* 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作.
* 你可以使用访问者对整个组合模式树执行操作.
* 可以同时使用访问者和迭代器模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同.

‍
