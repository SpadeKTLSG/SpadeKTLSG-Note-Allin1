‍

‍

### Header

‍

> OO, 面向对象

> 联动Java等处OO笔记本区间

‍

‍

## 概念

‍

面向对象编程<sup>（OOP）</sup>

面向对象<sup>（OO）</sup>思想, 一切皆对象

面向对象 = 对象 + 类 + 继承 + 通信

‍

## 特殊

‍

### POJOs

‍

‍

#### PO（persistant object）持久对象

‍

PO 就是对应数据库中某个表中的一条记录，多个记录可以用PO集合表示，PO中应该不包含对数据库的任何操作. 

‍

#### DO （Domain Object）领域对象

‍

就是从现实世界中抽离出来的有型或者无形的业务实体. 

‍

#### TO （Transfer Object）数据传输对象

‍

不同应用程序之间传输的对象

‍

#### DTO （Data Transfer Object） 数据传输对象

‍

这个概念来源于J2EE的设计模式，原来的目的是为了，EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指展示层和服务层之间的数据传输对象. 

‍

#### VO（value object） 值对象 、（view object）视图对象

‍

值对象        通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已，但应是抽象出来的业务对象，可以和表对应，也可以不对应，这个根据业务需要. 用new关键字创建，由GC回收. 

‍

视图对象       1.接收页面传递来的数据，封装成对象       2.将业务处理完的对象，封装成页面要用的数据

‍

‍

#### BO （business object）业务对象

从业务模型角度看，见UML元件领域模型中的领域对象. 封装业务逻辑的java对象，通过调用Dao方法，结合PO、VO进行操作. 主要作用是把业务逻辑封装为一个对象. 这个对象可以包括一个或多个其他对象，比如一个简历，有教育经历、工作经历、社会关系等等. 我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO. 建立一个对应简历的BO对象处理简历，每个BO包含这些PO. 这样处理业务逻辑的时候，我们就可以针对BO去处理. 

‍

‍

#### DAO （dao access object）数据访问对象

另:        是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负责持久层的操作. 为业务层提供接口. 此对象用于访问数据库. 通常和PO结合使用，DAO中包含的各种操作数据库的方法. 通过他的方法，结合PO对数据库进行相关的操作，夹在业务逻辑与数据库资源中间. 配合VO，提供数据库的CRUD操作. 

‍

#### POJO （plain ordinary java object）

简单无规则java对象

传统意义的java对象. 就是再说一些Object/Relation Mapping 工具中，能够做到维护数据库表记录的persisent  object 完全是一个符合Java Bean 规范的纯Java对象，没有增加别的属性和方法. 就是最基本的java bean，只有属性字段及 setter 和 getter方法. 

POJO让开发者可专注于业务逻辑和脱离框架的单元测试. 除此之外， 由于POJO并不须要继承框架的类或实现其接口，开发者能够极其灵活地搭建继承结构和建造应用.   
POJO的意义就在于它的简单而灵活性，因为它的简单和灵活，使得POJO能够任意扩展，从而胜任多个场合，也就让一个模型贯穿多个层成为现实. 

先写一个核心POJO，然后实现业务逻辑接口和持久化接口，就成了Domain Model； UI需要使用时，就实现数据绑定接口，变成VO（View Object）

‍

**POJO是DO/DTO/BO/VO的统称**

‍

‍

‍

‍

## 可见性

‍

可见性一般情况(不同语言语法可能不同)

可见 == √

||public|protected|default|private|
| --------------------| --------| -----------| ---------| ---------|
|同一类中|√|√|√|√|
|同一包 子类&其他类|√|√|√||
|不同包 子类|√|√|||
|不同包 其他类|√||||

‍

‍

‍

## 多态

‍

多态的使用: 向上转型和向下转型

‍

#### **向上转型**

**父类类型 引用名 = 子类引用;**

‍

父类的引用指向子类的对象

* 编译类型看左边，运行类型看右边
* 可以调用父类的所有成员（需遵守访问权限）
* 不能调用子类的特有成员
* 运行效果看子类的具体实现

‍

‍

#### **向下转型**

**子类类型 引用名 = (子类类型) 父类引用;**

‍

一个已经向上转型的子类对象，将父类引用转为子类引用

* 只能强制转换父类的引用，不能强制转换父类的对象
* 要求父类的引用必须指向的是当前目标类型的对象
* 当向下转型后，可以调用子类类型中所有的成员

‍

‍

#### **动态绑定**

​`Person p1 = new Student();p1.mission(); `​

‍

* 程序在编译阶段只知道 p1 是 Person 类型,而程序在运行的时候才知道堆中实际的对象是 Student 类型
* 程序在编译时 p1 被编译器看作 Person 类型, 因此编译阶段只能调用 Person 类型中定义的方法;p1 引用绑定的是 Person 类型中定义的 mission 方法（静态绑定）
* 程序在运行的时候，堆中的对象实际是一个 Student 类型，而 Student 类已经重写了 mission 方法;因此程序在运行阶段对象中绑定的方法是 Student 类中的 mission 方法（动态绑定）

‍

# 特性

‍

面向对象四大基本特性：封装、抽象、继承、多态

‍

## 封装

仅暴露有限的接口，授权外部来访问. 将逻辑集中，因此更可控；可读性、可维护性也更好；易用性也更好

‍

## 抽象

隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的

‍

## 继承

代码复用

‍

### 一般继承原则

final 类不能被继承

public也必须为 public. 

protected要么protected，要么public，不能声明为 private. 

private 的方法不能够被子类继承. 

父类中的 final 方法可以被子类继承，但是不能被重写. 

‍

‍

**继承会导致...**

‍

1. 代码在多个子类中重复
2. 运行行为不容易改变
3. 很难直到所有子类的全部行为
4. 父类变化牵一发而动全身

类应该对扩展开放, 对修改关闭

‍

‍

## 多态

子类可以替换父类. 提高代码的可扩展和可复用性
