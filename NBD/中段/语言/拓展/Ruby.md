--纯粹的面向对象编程语言

‍

## Header

‍

# 知识

‍

需要安装, 扩展名都是  **.rb**

单行注释以 `#`​​ 号开始, 多行注释以 `=begin`​​ 开始，以 `=end`​​ 结束

‍

## 底层特性

‍

1. 在Ruby中，只有`false`​​和`nil`​​表示false，其它所有值都表示true（包括`0`​​、`0.0`​​、`""`​​、`[]`​​）
2. Ruby的字符串是可改变的，在Ruby中常用`Symbol`​对象来表示不可变的字符串。提供了默认冻结字符串的选项: 源码开头添加魔术注释`# frozen_string_literal: true`​
3. 不建议使用继承

‍

‍

‍

‍

# 基础

‍

## 基本数型

‍

Ruby 支持的数据类型包括 **四** 大类型、**三** 个特殊的值 和 **两** 种数据结构

四大基本类型有：

1. Number
2. String
3. Ranges
4. Symbols

三个特殊的值是:

1. true
2. false
3. nil

两种数据结构是：

1. Array
2. Hash

‍

‍

### 字符串

‍

分为单引号字符串（'）和双引号字符串(")

‍

双引号字符串支持转义字符, 允许替换和使用反斜线符号

单引号标记的字符串不允许替换，且只允许使用 `\\`​ 和 `\'`​ 两个反斜线符号

‍

Ruby 中可以使用序列  **#{ **​**expr<sup>(可以是任意的 Ruby 表达式)</sup>**​ ** }**  替换任意 Ruby 表达式的值为一个字符串

‍

‍

#### 字符串变量

‍

支持一种采用 %q 和 %Q 来引导的字符串变量

* %q 用的是单引号引用规则
* %Q 用的是双引号引用规则

跟在 q 或 Q 后面的字符是分界符

分界符可以是任意一个非字母数字的单字节字符 如 `[,{,(,`​

```ruby
desc1 = %Q{Ruby 的字符串可以使用 '' 和 ""。}
desc2 = %q|Ruby 的字符串可以使用 '' 和 ""。|

puts desc1
puts desc2
```

‍

‍

‍

### 数值

‍

‍

#### 整型

‍

可以在整数前使用一个可选的前导符号

​`0`​ 对应 `octal`​，`0x`​ 对应 `hex`​，`0b`​ 对应 `binary`​

‍

如果在 `31`​ 位以内（ 4 字节 ），那为 `Fixnum`​ 实例; 超过，即为 `Bignum`​ 实例

‍

‍

#### 浮点型

‍

‍

‍

‍

### 数组

‍

是任何对象的有序整数索引集合, 自动增长不需要指定大小，索引从 0 开始，负数相对于数组的末尾计数

‍

数组字面量通过 `[ ]`​ 中以逗号分隔定义，且支持 `range`​ 定义

1. 通过 `[ ]`​ 索引访问
2. 通过赋值操作插入、删除、替换元素
3. 通过 `+`​ ，`－`​ 号进行合并和删除元素，且集合做为新集合出现
4. 通过 `<=>`​ 符号进行数组比较
5. 通过 `*`​ 号重复数组元素
6. 通过 `｜`​ 和 `&`​ 符号做并集和交集操作（ 注意顺序 ）

‍

```ruby
names = Array.new(20)
puts names.size  # 返回 20
```

创建数组

```
ary = Array.[](1, 3, 5, 7, 11)
ary = Array[1, 3, 5, 7, 11]
ary = Array(5..9)
puts "#{ary}"
```

‍

### 哈希表

‍

Ruby 哈希是在大括号内放置一系列键/值对，键和值之间使用逗号和序列 `=>`​ 分隔

,尾部的逗号会被忽略

‍

```
myhash = Hash.new( "month" )
myhash = Hash.new "month"
myhash = {"a" => 100, "b" => 200}
```

‍

‍

### 范围

一个范围表示一个区间, 通过设置一个开始值和一个结束值来表示

范围可使用 `s..e`​ 和 `s...e`​ 来构造，或者通过 `Range.new`​ 来构造

1. 使用 `..`​ 构造的范围从开始值运行到结束值 ( 包含结束值 )
2. 使用 `...`​ 构造的范围从开始值运行到结束值 (不包含结束值 )

当作为一个迭代器使用时，范围会返回序列中的每个值

范围 `(1..5)`​ 意味着它包含值 `1, 2, 3, 4, 5`​，范围 `(1...5)`​ 意味着它包含值 `1, 2, 3, 4`​

‍

以不同的方式使用范围：

1. 作为序列的范围
2. 作为条件的范围
3. 作为间隔的范围

‍

#### 作为序列的范围

表达序列是最常见的序列。

表达序列有一个起点、一个终点和一个在序列产生连续值的方式

Ruby 使用  **''..''**  和  **''...''**  范围运算符创建表达序列

两点形式创建一个包含指定的最高值的范围，三点形式创建一个不包含指定的最高值的范围

```
(1..5)        #==> 1, 2, 3, 4, 5
(1...5)       #==> 1, 2, 3, 4
('a'..'d')    #==> 'a', 'b', 'c', 'd'
```

‍

### 作为条件的范围

范围也可以用作条件表达式

下面的代码片段从标准输入打印行，其中每个集合的第一行包含单词 start ，最后一行包含单词 end

```
while gets
   print if /start/../end/
end
```

‍

### 作为间隔的范围

范围的最后一个用途是间隔检测：检查指定值是否在指定的范围内

需要使用 === 相等运算符来完成计算

‍

‍

‍

## 基本量

‍

### 变量

‍

五种类型的变量：

1. **一般小写字母、下划线开头：**  变量(Variable)
2. ​ **​`$`​** ​**开头：**  全局变量 (Global variable)
3. ​ **​`@`​** ​**开头：**  实例变量 (Instance variable)
4. ​ **​`@@`​** ​**开头：**  类变量 (Class variable)，类变量被共享在整个继承链中
5. **大写字母开头：**  常数 (Constant)

‍

‍

#### 全局变量

未初始化的全局变量的默认值为 **nil**

> 使用 -w 选项后，未初始化的全局变量会产生警告

‍

‍

#### 实例变量

未初始化的实例变量的的默认值为 **nil**

> 在使用 -w 选项后，未初始化的实例变量会产生警告信息

‍

‍

#### 类变量

类变量以 `@@`​​ 开头，且必须初始化后才能在方法中使用

引用一个未初始化的类变量会产生错误

> 在使用 -w 选项后，重载类变量会产生警告

‍

‍

#### 局部变量

局部变量以小写字母或下划线(_) 开头。 局部变量的作用域从 class、module、def、do 到相对应的结尾或者从左大括号到右大括号 {}

当调用一个未初始化的局部变量时，它被解释为调用一个不带参数的方法

对未初始化的局部变量赋值也可以当作是变量声明。

局部变量的生命周期在 Ruby 解析程序时确定 局部变量会一直存在，直到当前域结束为止。

‍

#### 特殊变量

Ruby 语言中有一些特殊的变量，它们有着局部变量的外观，但行为却像常量, 而且不能给这些特殊变量赋任何值。

‍

* **self:**  当前方法的接收器对象
* **true:**  代表 true 的值
* **false:**  代表 false 的值
* **nil:**  代表 undefined 的值
* FILE **:**  当前源文件的名称
* LINE **:**  当前行在源文件中的编号

‍

### 常量

‍

1. Ruby 语言中的常量以大写字母开头
2. 定义在类或模块内的常量可以从类或模块的内部访问
3. 定义在类或模块外的常量可以被全局访问
4. 常量不能定义在方法内
5. 引用一个未初始化的常量会产生错误
6. 对已经初始化的常量赋值会产生警告

‍

‍

## 基础语法

‍

### 赋值

支持对变量的并行赋值: 这使得多个变量可以通过一行的 Ruby 代码进行初始化

```
a, b, c = 10, 20, 30
```

‍

类似python, 并行赋值可以用来交换两个变量的值

```
a, b = b, c
```

‍

### 三元运算

 (?:)

```
condition ? expression1 : expression2
```

如果 **condition** 条件为真，则执行 **expression1** 并返回执行的结果 如果 **condition** 条件为假，则执行 **expression2** 并返回执行的结果

‍

‍

### if

```
code if condition
```

‍

### *unless*

和 if 语句作用相反

‍

### case

在Ruby中，使用’`case`​‘代替’`switch`​‘关键字，以及使用’`when`​‘代替’`case`​‘关键字。 `case`​语句将一个语句与多个条件进行匹配，就像其他语言中的`switch`​语句一样

```ruby
case expression  
[when expression [, expression ...] [then]  
   code ]...  
[else  
   code ]  
end
```

‍

当 case 的 "表达式" 部分被省略时，将计算第一个when条件部分为真的表达式

```
a = false
b = true
c = false

case
when a then puts 'a is true'
when b then puts 'b is true'
when c then puts 'c is true'
end
```

‍

‍

### then

通常可以省略, 但若想在一行内写出完整的 when 式，则必须以 then 隔开条件式和程式区块

```
when a == 4 then a = 7 end
```

‍

‍

### while

```
while conditional [do]  
   code1
end
```

或者

```
while conditional [:]  
   code
end
```

 当 *conditional* 为真时，执行 *code1*

语法中 **do** 或  **:**  可以省略不写 但若要在一行内写出 while 式，则必须以 do 或 : 隔开条件式或程式区块

‍

#### 修饰符

```
statement while condition  
```

或

```
begin 
  statement  
end while condition  
```

当 *conditional* 为真时，执行 *statement*

如果 *while* 修饰符跟在一个没有 *rescue* 或 ensure 子句的 *begin* 语句后面， *statement* 会在 *condition* 判断之前执行一次。

‍

‍

### until

‍

```
until conditiona [do]  
   statement
end
```

 当 *conditiona* 为假时，执行 *statement*

语法中 do 可以省略不写。但若要在一行内写出 until 式，则必须以 do 隔开条件式或程式区块

‍

#### 修饰符

```
statement until condition
```

或

```
begin
   statement
end until condition
```

当 *condition* 为 false 时，执行 *statement*

如果 *until* 修饰符跟在一个没有 *rescue* 或 ensure 子句的 *begin* 语句后面， *statement* 会在 *condition* 判断之前执行一次

‍

‍

### for

```
for variable [, variable ...] in expression [do]
   statement
end
```

‍

*for...in* 循环几乎是完全等价于

```
(expression).each do |variable[, variable...]| code end
```

区别就是 for 循环不会为局部变量创建一个新的作用域

语法中 do 可以省略不写。但若要在一行内写出 for 式，则必须以 do 隔开条件式或程式区块。

‍

‍

#### next

用于跳过剩下的代码，开始进入下一个循环迭代

‍

#### redo

用于重新开始 redo 所在代码块的循环迭代

```ruby

cnt = 0
for i in 0..3
    puts "局部变量的值为 #{i}"

    if i < 3 and cnt < 2 then
       cnt += 1
       redo
    end
end

puts "cnt = #{cnt}"
```

‍

### alias

用于为方法或全局变量起别名。别名不能在方法主体内定义

即使方法被重写，方法的别名也保持方法的当前定义

‍

1. 为编号的全局变量（\$1, \$2,...）起别名是被禁止的
2. 重写内置的全局变量可能会导致严重的问题。

```
alias 别名 方法名
alias 别名 全局变量
```

‍

### undef

**undef** 语句用于取消方法定义, 不能出现在方法主体内

通过使用 *undef* 和 *alias* ，类的接口可以从父类独立修改 但请注意，在自身内部方法调用时，它可能会破坏程序

```
undef 方法名
```

‍

‍

### 输入输出

‍

**print**

print 输出“”内的内容会识别转义符，并 **不会** 自动化换行

‍

**puts**

puts 跟print一样输出“”内的内容会识别转义符，但是puts会自动化换行

‍

**p**

p 输出的不仅仅是“”内的内容，而且是会把“”也输出，而且 **不会** 识别转义符，但是会自动化换行

‍

‍

### 运算符

‍

**Ruby 语言中，大多数运算符实际上是方法调用(类比Cpp的重载运算符)**

例如，a + b 被解释为 a.+(b)，其中指向变量 a 的 + 方法被调用，b 作为方法调用的参数

对于每个运算符（+ - * / % ** & | ^ << >> && ||），都有一个相对应的缩写赋值运算符（+= -= 等等）

‍

|运算符|描述|
| :-------| :------------------------------------------------------------------------------------------------------------------------------------------------|
|==|检查两个操作数的值是否相等，如果相等则条件为真|
|!=|检查两个操作数的值是否相等，如果不相等则条件为真|
|>|检查左操作数的值是否大于右操作数的值，如果是则条件为真|
|<|检查左操作数的值是否小于右操作数的值，如果是则条件为真|
|>=|检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真|
|<=|检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真|
|<=>|联合比较运算符。如果第一个操作数等于第二个操作数则返回 0，如果第一个操作数大于第二个操作数则返回 1，如果第一个操作数小于第二个操作数则返回 -1。|
|===|用于测试 case 语句的 when 子句内的相等|
|.eql?|如果接收器和参数具有相同的类型和相等的值，则返回 true|
|equal?|如果接收器和参数具有相同的对象 id，则返回 true。|

‍

#### 点运算符

点号(.)运算符用来访问类或者模块或实例的**方法 **

通过在方法名称前加上类或模块名称和 . 来调用类或模块中的**方法**

‍

#### 双冒号运算符

双冒号(::)运算符用来访问类或模块的**常量**

通过在类或模块名称前加上两个冒号 :: 来引用类或模块中的**常量**

> **注意** : Ruby 语言中的类和方法也可以被当作常量

* 如果 `::`​ 前的表达式为类或模块名称，则返回该类或模块内对应的常量值
* 如果 `::`​ 前未没有前缀表达式，则返回主 Object 类中对应的常量值

‍

### 迭代器

‍

#### each迭代器

返回数组或哈希的所有元素

```ruby
collection.each do |variable|
   code
end
```

*each* 迭代器总是与一个块关联。 它向块返回数组的每个值，一个接着一个。 值被存储在变量 **i** 中，然后显示在屏幕上

‍

#### collect迭代器

*collect* 迭代器返回集合的所有元素

​`collection = collection.collect`​

*collect* 方法不是数组间进行复制的正确方式。 有另一个称为 *clone* 的方法，用于复制一个数组到另一个数组

当您想要对每个值进行一些操作以便获得新的数组时，通常使用 collect 方法

‍

‍

### 块

‍

比方法更简单的组合语句的方式，这种方式就是 **块(block)**

* 块中的代码总是包含在大括号 `{}`​ 内
* 块总是从与其具有相同名称的函数调用，也就是说如果块的名称为 hello，那么要使用函数 hello 来调用这个块
* 块也可以被 *yield* 语句来调用块

‍

语法格式

```
block_name {
   statement1
   statement2
   ..........
}
```

‍

#### yield

块可以被 *yield* 语句来调用。

Ruby 允许使用带有参数的 *yield* 语句来调用块，也允许没有参数的 **yield** 语句来调用块

```
def hello
    puts "在 hello 方法内"
    yield
    puts "你又回到了 hello 方法内"
    yield
end

hello{ puts "你在块(block) 内" }
```

有参数的 yield 语句

*yield* 语句后跟着参数。我们甚至可以传递多个参数。

在块中，可以在两个竖线之间放置一个变量来接受参数。 因此，yield 17 语句向 hello 块传递值 17 作为参数

```
def hello
    puts "在 hello 方法内"
    yield 17             
    puts "你又回到了 hello 方法内"
    yield 33
end

hello{ |i| puts "你在块(block #{i}) 内" }  
```

如果想要传递多个参数，那么 *yield* 语句则会是这样的：`yield a, b`​ 相应的，在块中的格式如下 `hello {|a, b| statement}`​ ， 参数使用逗号分隔

‍

#### BEGIN/END

‍

每个 Ruby 源文件可以声明当文件被加载时要运行的代码块（BEGIN 块），以及程序完成执行后要运行的代码块（END 块）

1. 一个程序可以包含多个 BEGIN 和 END 块。
2. BEGIN 块按照它们出现的顺序执行。
3. END 块按照它们出现的相反顺序执行。

```ruby
BEGIN {
   code
}
END {
   code
}
```

‍

### 模块

‍

模块 (Module) 是一种把方法、类和常量组合在一起的方式。其定义了一个命名空间，相当于一个沙盒，在里边的方法和常量不会与其它地方的方法常量冲突

**Ruby 语言允许定义多个函数名称相同但是功能不同的模块**

‍

带来了两大好处：

1. 模块提供了一个 *命名空间* 和避免名字冲突
2. 模块实现了 *mixin* 装置

‍

模块类似与类，但

* 模块不能实例化
* 模块没有子类
* 模块只能被另一个模块定义

‍

语法格式如下

```
module <ModuleName>   
   statement1
   statement2
   ...........
end
```

1. 模块中的常量命名与类常量命名类似，以大写字母开头
2. 模块中的方法定义看起来和类也相似
3. 可以使用模块名称和两个冒号来引用一个常量

‍

示例

```
module Hello
   PI = 3.141592654
   def Hello.sin(x)
   # ..
   end

   def Hello.cos(x)
   # ..
   end
end
```

‍

#### require

‍

用于加载模块

如果一个第三方的程序想要使用任何已定义的模块，可以使用 Ruby *require* 语句来加载模块文件, 文件扩展名  **.rb** 不是必需的

如果模块是定义在一个单独的文件中，那么在嵌入模块之前就需要使用 *require* 语句引用该文件

‍

```
require filename
```

‍

‍

#### include

‍

允许在类中嵌入模块

Ruby 语言提供了 **include** 语句用来在类中嵌入模块

```
include modulename
```

‍

### 方法

用于捆绑一个或多个重复的语句到一个单元中, 应以小写字母开头。

> 如果以大写字母作为方法名的开头，Ruby 可能会把它当作常量，从而导致不正确地解析调用

Ruby 方法应在调用之前定义，否则 Ruby 会产生未定义的方法调用异常

‍

语法格式

```
def method_name [( [arg [= default]]...[, * arg [, &expr ]])]
   expr..
end
```

Ruby 允许声明参数数量可变的方法, 参数前加上`*`​

‍

定义一个没有参数的方法如下

```
def method_name 
   expr..
end
```

定义一个接受参数的方法如下

```
def method_name (var1, var2)
   expr..
end
```

‍

为参数设置默认值

如果方法调用时未传递必需的参数则使用默认值

```
def method_name (var1=value1, var2=value2)
   expr..
end
```

‍

调用方法

调用无参数的方法时，只需要使用方法名即可

```
method_name
```

调用带参数的方法时，在写方法名时还要带上参数

```
method_name 25, 30
```

使用带参数方法最大的缺点是调用方法时需要记住参数个数。 例如，如果向一个接受三个参数的方法只传递了两个参数，Ruby 会显示错误

‍

返回值

Ruby 从方法中返回值有两种方式：

1. 默认返回最后一个表达式的值
2. 使用 return 语句显示返回

Ruby 中的每个方法默认都会返回一个值。这个返回的值是最后一个语句的值

*return* 语句用于从 Ruby 方法中显示返回一个或多个值

‍

‍

‍

## 类

‍

```
class ClassName
end
```

可以使用关键字 *end* 终止一个类。 *类* 中的所有数据成员都是介于类定义和 *end* 关键字之间

或者

```
class ClassName
{

}
```

> 不推荐使用 大括号({}) 这种方式

‍

‍

### 对象

方法 *new* 是一种独特的方法，在 Ruby 库中预定义。Ruby 语言中的 new 方法属于 *类* 方法

```
object_name = ClassName.new
```

对象名称后跟着等号（=），等号后跟着类名，然后是点运算符和关键字 *new*

‍

#### 自定义创建

给方法 *new* 传递参数用于初始化类变量, 当想要给 *new* 方法传递参数时，我们需要通过创建类的同时声明方法 *initialize*

*initialize* 方法是一种特殊类型的方法，会在调用带参数的类的 *new* 方法时执行

‍

‍

### 成员方法

类中的每个方法是以关键字 **def** 开始，后跟方法名。方法名总是以 **小写字母** 开头, 可以使用关键字 *end* 来结束一个方法的定义

‍

#### 访问权限

Ruby 语言中，当方法定义在类的外部，方法默认标记为 *private* 如果方法定义在类中的，则默认标记为 **public**

方法默认的可见性和 *private* 标记可通过模块（Module）的 *public* 或 *private* 改变。

‍

一般情况下，如果想要访问类的方法时，首先必须实例化类。然后，就可以通过对象访问类的任何成员

‍

通过在类名后跟着一个点号，点号后跟着方法名来声明定义的方法可以直接访问，而不需要创建类实例 (类似static)

‍

## 异常

Ruby 提供了一个完美的处理异常的机制，可以在 *begin/end* 块中附上可能抛出异常的代码，并使用 *rescue* 子句告诉 Ruby 完美要处理的异常类型

### rescue

```
begin #开始

    raise.. #抛出异常

rescue [ExceptionType = StandardException] #捕获指定类型的异常 缺省值是StandardException
    $! #表示异常信息
    $@ #表示异常出现的代码位置
else #其余异常
 ..
ensure #不管有没有异常，进入该代码块

end #结束
```

从 *begin* 到 *rescue* 中的一切是受保护的。 如果代码块执行期间发生了异常，控制会传到 *rescue* 和 *end* 之间的块

对于 *begin* 块中的每个 *rescue* 子句，Ruby 把抛出的异常与每个参数进行轮流比较。 如果 rescue 子句中命名的异常与当前抛出的异常类型相同，或者是该异常的父类，则匹配成功

如果异常不匹配所有指定的错误类型，可以在所有的 *rescue* 子句后使用一个 *else* 子句

*rescue* 块可以用来捕获异常

*retry* 语句从开头开始执行 *begin* 块

‍

示例

```
begin
    # 这段代码抛出的异常将被下面的 rescue 子句捕获
rescue
    # 这个块将捕获所有类型的异常
    retry  # 这将把控制移到 begin 的开头
end
```

‍

### raise

用于抛出异常

下面的方法在调用时抛出异常。它的第二个消息将被输出。

‍

```
raise 
```

或

```
raise "Error Message"
```

或

```
raise ExceptionType, "Error Message"
```

或

```
raise ExceptionType, "Error Message" condition
```

第一种形式简单地重新抛出当前异常（如果没有当前异常则抛出一个 RuntimeError）。这用在传入异常之前需要解释异常的异常处理程序中。

第二种形式创建一个新的 *RuntimeError* 异常，设置它的消息为给定的字符串。该异常之后抛出到调用堆栈。

第三种形式使用第一个参数创建一个异常，然后设置相关的消息为第二个参数。

第四种形式与第三种形式类似，您可以添加任何额外的条件语句（比如 *unless* ）来抛出异常。

‍

‍

### ensure

有时候，无论是否抛出异常，都要确保一些处理在代码块结束时完成。比如在进入时打开了一个文件，当退出块时，需要确保关闭文件

*ensure* 子句做的就是这个。 ensure 放在最后一个 rescue 子句后，并包含一个块终止时总是执行的代码块。 它与块是否正常退出、是否抛出并处理异常、是否因一个未捕获的异常而终止，这些都没关系， *ensure* 块始终都会运行。

‍

```
begin 
   #.. 过程
   #.. 抛出异常
rescue 
   #.. 处理错误 
ensure 
   #.. 最后确保执行
   #.. 这总是会执行
end
```

‍

‍

### else

如果提供了 *else* 子句，它一般是放置在 *rescue* 子句之后，任意 *ensure* 之前

*else* 子句的主体只有在代码主体没有抛出异常时执行

‍

```
begin 
   #.. 过程 
   #.. 抛出异常
rescue 
   #.. 处理错误
else
   #.. 如果没有异常则执行
ensure 
   #.. 最后确保执行
   #.. 这总是会执行
end
```

‍

使用 $! 变量可以捕获抛出的错误消息

‍

### Catch-Throw

raise 和 rescue 的异常机制能在发生错误时放弃执行， 有时候需要在正常处理时跳出一些深层嵌套的结构。 此时 catch 和 throw 就派上用场了。

*catch* 定义了一个使用给定的名称（可以是 Symbol 或 String）作为标签的块。块会正常执行直到遇到一个 throw

‍

```
throw :lablename
#.. 这不会被执行
catch :lablename do
#.. 在遇到一个 throw 后匹配将被执行的 catch
end
```

或

```
throw :lablename condition
#.. 这不会被执行
catch :lablename do
#.. 在遇到一个 throw 后匹配将被执行的 catch
end
```

‍

### 类 Exception

Ruby 的标准类和模块抛出异常。

所有的异常类组成一个层次，包括顶部的 Exception 类在内。

下一层是七种不同的类型： - Interrupt - NoMemoryError - SignalException - ScriptError - StandardError - SystemExit

Fatal 是该层中另一种异常，但是 Ruby 解释器只在内部使用它。

ScriptError 和 StandardError 都有一些子类，但是在这里我们不需要了解这些细节。 最重要的事情是创建我们自己的异常类，它们必须是类 Exception 或其子代的子类。

```
class FileSaveError < StandardError
   attr_reader :reason
   def initialize(reason)
      @reason = reason
   end
end
```

‍

‍

‍

‍

# 高级

‍
