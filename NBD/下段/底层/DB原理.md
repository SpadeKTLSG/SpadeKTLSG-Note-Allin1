‍

### Header

‍

‍

## 数据库开发

‍

### 分阶段项目设计

1. 数据库设计阶段

    * 参照页面原型以及需求文档设计数据库表结构
2. 数据库操作阶段

    * 根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作
3. 数据库优化阶段

    * 通过数据库的优化来提高数据库的访问性能. 优化手段：索引、SQL优化、分库分表等

‍

‍

## 关系DB

‍

### 关系模型

‍

#### 关系数据结构

‍

* 关系(值)

  * 域

    * 一组具有相同数据类型的值的集合
  * 笛卡尔积

    * 一个域中的元素与另外的域中的元素分别结合构成一个元组
  * 关系

    * 候选码:某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（candidate key）
    * 主码:若一个关系有多个候选码，则选定其中一个为主码（primary key）
    * 主属性和非主属性:候选码的诸属性称为主属性（prime attribute）  
      不包含在任何候选码中的属性称为非主属性（non-prime attribute）或非码属性（non-key attribute）
    * 全码:关系模式的所有属性是这个关系模式的候选码，称为全码（all-key）
* 关系模式(型)

  * 是对关系的描述
* 关系数据库

‍

##### 关系数据库

有型和值的区分

‍

* 型    关系数据库模式 (描述)
* 值    这些关系模式某一刻的对应关系的集合, 通常就称为关系数据库

‍

##### 关系类型

‍

* 基本关系(基本表)

  * 实际存在的表,是实际存储数据的表示,不可再分,必须规范化(也就是达到第一范式1NF)
* 查询表

  * 查询结果对应的表
* 视图表

  * 由基本表或其他视图表导出的表,是虚表,不对应实际存储数据

‍

‍

##### 基本关系性质

‍

① 列是同质的

* 每一列中的分量是同一类型的数据，来自同一个域

‍

② 不同的列可出自同一个域

* 其中的每一列称为一个属性
* 不同的属性要给予不同的属性名

‍

③ 列的顺序无所谓

* 列的次序可以任意交换
* 遵循这一性质的数据库产品(如ORACLE)，增加新属性时，永远是插至最后一列。但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了属性顺序

‍

④ 任意两个元组的候选码不能完全相同

* 候选码是可以惟一标识一个元组的属性或属性组。若一个关系中的候选码有多个，则选择一个作为主码

‍

⑤ 行的顺序无所谓

* 行的次序可以任意交换
* 遵循这一性质的数据库产品(如ORACLE)，插入一个元组时永远插至最后一行。但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了元组的顺序

‍

⑥ 分量必须取原子值

* 每一个分量都必须是不可分的数据项。

‍

‍

### 关系操作

‍

‍

#### 基本操作

‍

* 选择
* 投影
* 并
* 差
* 笛卡尔积

‍

* 选择σ (Select)(横挑）    从一个表中把满足条件的元组选出来  
  选择是一种单目运算，即对一个关系施加的运算，按给定条件从关系中挑选满足条件的元组组成的集合  
  语法格式：σ<选择条件>（<关系名>）
* 投影π (Project)(竖挑)     将需要的属性列出来  
  投影操作是单目运算，从关系中挑选指定的属性组成的新关系  
  语法格式：π<属性表>（<关系名>）
* 并 ∪    把两个模式相同的元组并起来
* 集合差-    把属于关系A不属于关系B的元组找出来
* 笛卡尔乘积×   两个关系的拼接

‍

‍

‍

‍

### 关系完整性

关系模型中的三类完整性约束 + 规则

* 实体完整性(主键)
* 参照完整性(外键)
* 用户定义的完整性

‍

* 关系模型的完整性规则是对关系的某种约束条件
* 实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。

‍

‍

### 关系代数

重点 - 计算题

‍

* 关系代数是一种抽象的查询语言，用对关系的运算来表达查询
* 关系代数的运算对象是关系，运算结果亦为关系

关系代数运算中的基本运算包括**并 (∪)、差 (-)、广义笛卡尔积 (×)、投影 (π)和选择 (σ)**

‍

1. **关系操作优先级高于集合操作;**
2. **一元操作（单目）优先级高于二元操作。**

‍

#### 传统的集合运算

普通的集合运算

* 并、交、差 + 笛卡尔积

‍

##### 并、交、差

参与集合的两个关系要满足两个条件:

1. 属性个数相同
2. 属性类型要一样

‍

参与并、差操作的两个关系的元组必须限制为同类型的，即具有相同的目，且对应的属性的域相同——并兼容

‍

‍

##### 笛卡尔积

1. 结果模式包括进行操作的两个表的所有属性，两张表的**每条元组**之间**两两**拼接
2. 若R和S中有相同的属性名，在这些属性名前加上关系名作为限定词(如：R.B,S.B)，进行区别。

‍

‍

#### 专门的关系运算

‍

##### 选择

选择操作σ (Select)(横挑）从一个表中把满足条件的元组选出来

* 选择是一种单目运算，即对一个关系施加的运算，按给定条件从关系中挑选满足条件的元组组成的集合 。
* 语法格式：**σ&lt;选择条件&gt;（&lt;关系名&gt;）**

‍

##### 投影

投影操作π (Project)(竖挑) 将需要的属性列出来

* 投影操作是单目运算，从关系中挑选指定的属性组成的新关系。
* 语法格式：**π&lt;属性表&gt;（&lt;关系名&gt;）**

‍

##### 连接

**R ∞&lt;连接条件&gt; S＝σ&lt;连接条件&gt;（R * S）**

* 解释:关系R和关系S在该条件的连接操作等于关系R和关系S先做笛卡尔乘积,再按照该条件做选择操作

‍

**等值连接**

* 一种特殊的条件连接，连接条件只有等值的条件
* 结果模式和笛卡尔乘积的模式类似，把等值的属性去掉一列

‍

‍

**自然连接**

两张表在所有的公共属性上做等值连接

* 步骤：

  1. 作R x S（笛卡儿积）
  2. 在R x S 上选择同名的属性组
  3. 去掉重复属性

* 一般的连接操作是从**行**的角度进行运算，但自然连接还需要**取消重复列**，所以是同时**从行和列**的角度进行运算

‍

**外连接**

将悬浮元组也保留在结果关系里

只保留一侧就是对应的X外连接

‍

##### 除

**A/B = {&lt;x&gt;|ョ&lt;x,y&gt;∈A，∀&lt;y&gt;∈B}**

计算思路：比如对于A/B来说，我们要找在关系A中跟关系B中所有y值都有联系的x值。

【也就是找出在关系B中没有一个y值与A的是没有联系的。否定的否定,就是找出B中的列的属性在A中都有关联的属性,B中列的属性不写.】

‍

* 先在A中找不满足除法条件的x

  * 先把A做一个投影，投影到x属性
  * 将投影结果和关系B做一个笛卡尔乘积
  * 用笛卡尔乘积结果-A
  * 对上一步结果做一个投影，投影到x
* 把关系A所有的x值减去所有不满足条件的x值

  * 把关系A投影到x
  * 投影结果减去上一操作找到的所有不满足条件的x值

‍

‍

#### 关系代数运算小册

‍

* 并Union (∪)

  * R和S的并，R∪S，是在R或S或两者中的元素的集合
  * 一个元素在并集中只出现一次
  * R和S必须同类型（属性集相同、次序相同，但属性名可以不同）
* 交Intersect (∩)

  * R和S的交，R∩S，是在R和S中都存在的元素的集合
  * 一个元素在交集中只出现一次
  * R和S必须同类型（属性集相同、次序相同，但属性名可以不同）
* 差Minus (-)

  * R和S的差，R-S，是在R中而不在S中的元素的集合
  * R和S必须同类型（属性集相同、次序相同，但属性名可以不同）
* 投影Projection(π)

  * 从关系R中选择若干属性组成新的关系
  * πA1,A2,…,An(R),表示从R中选择属性集A1,A2,…,An组成新的关系
  * 列的运算
  * 投影运算的结果中,也要去除可能的重复元组
* 广义笛卡儿积(×)

  * 关系R、S的广义笛卡儿积是两个关系的元组对的集合所组成的新关系
  * R×S：

    * 属性是R和S的组合（有重复）
    * 元组是R和S所有元组的可能组合
    * 是R、S的无条件连接，使任意两个关系的信息能组合在一起
* 选择Selection(σ)

  * 从关系R中选择符合条件的元组构成新的关系
  * σC(R),表示从R中选择满足条件(使逻辑表达式C为真)的元组
  * 行的运算
* 条件连接(θ)

  * 从R×S的结果集中，选取在指定的属性集上满足AθB条件的元组，组成新的关系
  * θ是一个关于属性集的比较运算符
  * θ为“＝”的连接运算称为等值连接。
* 自然连接

  * 从R×S的结果集中，选取在某些公共属性上具有相同值的元组，组成新的关系
  * R、S的公共属性

    * 属性集的交集（名称及类型相同）
  * 公共属性在结果中只出现一次
  * 是一种特殊的等值连接
* 关系代数—除( ÷ )

  * 给定关系R(X,Y)和S(Y,Z)，其中X, Y, Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。
  * R÷S = {tr[X]| tr∈R∧πy       (S)Yx}
  * 其中Yx为x在R中的象集，x=tr[X]。
  * 例子

‍

‍

## SQL

SQL:结构化查询语言（Structured Query Language）

‍

‍

### 定义

(略)

‍

非过程化语言

* SQL语言进行数据库操作时，只需要提出“做什么”，不需要指明“怎么做”。“怎么做”是由DBMS来完成

‍

SQL的形式

* 交互式SQL

  * 一般DBMS都提供联机交互工具
  * 用户可直接键入SQL命令对数据库进行操作
  * 由DBMS来进行解释
* 嵌入式SQL

  * 能将SQL语句嵌入到高级语言（宿主语言）
  * 使应用程序充分利用SQL访问数据库的能力、宿主语言的过程处理能力
  * 一般需要预编译，将嵌入的SQL语句转化为宿主语言编译器能处理的语句

‍

‍

#### 三级模式结构对应的关系

‍

* 外模式–>视图

  * 视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中**只存放视图的定义而不存放视图对应的数据**。这些数据仍存放在导出视图的基本表中，因此视图是一个**虚表**。视图在概念上与基本表等同，用户可以在视图上再定义视图。
* 模式–>基本表

  * 基本表是本身**独立存在**的表，在关系数据库管理系统中**一个关系就对应一个基本表**。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。
* 内模式–>存储文件

  * 存储文件的逻辑结构组成了关系数据库的内模式，存储文件的物理结构对最终用户是隐蔽的。

‍

‍

#### 组成

‍

* 数据定义语言（DDL，Data Definition Language）

  ‍

  数据定义语言是指用来定义和管理数据库以及数据库中的各种对象的语句，这些语句包括CREATE、ALTER和DROP等语句。在SQL Server中，数据库对象包括表、视图、触发器、存储过程、规则、缺省、用户自定义的数据类型等。这些对象的创建、修改和删除等都可以通过使用CREATE、ALTER、DROP等语句来完成。

  ‍

  * 常见数据类型

    * 字符型：

      * 定长字符型 char(n) 由于是定长，所以速度快
      * 变长字符型 varchar(n)
    * 数值型：

      * 整型 int(或integer)   -231~+231
      * 短整型 smallint -215~+215的
      * 浮点型 real、float、double
      * 数值型 numeric (p [,d])
    * 日期／时间型：

      * DateTime
    * 文本和图像型

      * Text：存放大量文本数据。在SQLServer中，Text对象实际为一指针
      * Image：存放图形数据
* 数据操纵语言（DML，Data Manipulation Language）

  * 数据操纵语言是指用来查询、添加、修改和删除数据库中数据的语句，这些语句包括SELECT、INSERT、UPDATE、DELETE等。在默认情况下，只有sysadmin、dbcreator、db_owner或db_datawriter等角色的成员才有权利执行数据操纵语言。
* 数据控制语言（DCL，Data Control Language）

  * 数据控制语言（DCL）是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、REVOKE 、DENY等语句，在默认状态下，只有sysadmin、dbcreator、db_owner或db_securityadmin等角色的成员才有权利执行数据控制语言。

‍

‍

‍

## 安全性

‍

### 方法

‍

1. 用户标示鉴定
2. 存取控制
3. 审计
4. 数据加密
5. 视图的保护

‍

‍

### 存储控制

‍

#### 自主存储控制

通过SQL的GRANT语句和REVOKE语句来实现

‍

* 用户对不同的数据对象有不同的存取权限
* 不同的用户对同一对象也有不同的权限
* 用户还可以将其拥有的存取权限转授给其他用户

‍

##### Grant授予

‍

把对表SC的INSERT权限授予U5用户，并允许将此权限再授予其他用户。

```sql
GRANT INSERT
ON TABLE SC 
TO U5
WITH GRANT OPTION;
-- 执行此SQL语句后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限，即由U5用户发上述GRANT命令给其他用户。例如U5可以将此权限授予U6（例4.6）。

```

‍

##### Revoke收回

‍

把用户U5对SC表的INSERT权限收回

```sql
REVOKE INSERT 
ON TABLE SC 
FROM U5 CASCADE;
-- 将用户U5的INSERT权限收回的同时，级联（CASCADE）收回了U6和U7的INSERT权限，否则系统将拒绝执行该命令。
```

‍

‍

#### 强制存储控制

‍

* 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。

  1. 主体是系统中的活动实体，既包括数据库管理系统所管理的实际用户，也包括代表用户的各进程。
  2. 客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等
* 强制存取控制是**对数据本身进行密级标记**，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据，从而提供了更高级别的安全性。

‍

* 实现MAC时首先要实现DAC
* 规则

  * 仅当主体的许可证级别**大于或等于**客体的密级时，该主体才能**读**取相应的客体。
  * 仅当主题的许可证级别**等于**客体的密级时，该主体才能**写**相应的客体。
* 规则的共同点

  * **禁止**了拥有**高**许可证级别的主体更新**低密级**的数据对象

‍

### 视图

通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。

就是通过视图对不同的用户授予不同的权限

‍

### 审计

‍

记录操作到日志

‍

进行审计

```sql
Audit Alter,Update
On SC;
```

‍

取消审计

```sql
NOAUDIT Alter...
```

‍

### 数据加密

‍

‍

## 完整性

‍

### 实体完整性

主属性

关系模型的实体完整性在CREATE TABLE中用**PRIMARY KEY**定义

‍

1. 列级约束条件:定义在属性的后面

    * ```sql
      Sno CHAR(9) PRIMARY KEY
      ```
2. 表级约束条件:单独成一行,使用语句单独定义

    * ```sql
      PRIMARY KEY(Sno)
      ```

‍

‍

* 实体完整性

  * ```sql
    create table student
    (Sno char(9) primary key,
     ...);

     //表级
     create table student
     (	Sno char(9),
      	....,
    	 primary key(Sno)
     )
    ```
* 参照完整性

  * ```sql
    create table sc
    (	sno char(9) not null,
     	foreign key(sno) references student(Sno)
     	on delete cascade
    	on update cascade
    )


    ```
* 用户定义完整性* 属性上 not null, unique, check(...)

  * 元组：check(...)

‍

‍

### 参照完整性

外码

关系模型的参照完整性在CREATE TABLE中用FOREIGN KEY短语定义哪些列为**外码**，用**REFERENCES**短语指明这些外码**参照哪些表的主码**

‍

```sql
CREATE TABLE SC
(Sno CHAR（9）NOT NULL,
  Cno CHAR（4）NOT NULL,
  Grade SMALLINT,
  PRIMARY KEY（Sno，Cno）,-- 在表级定义实体完整性
  FOREIGN KEY（Sno）REFERENCES Student（Sno）,-- 在表级定义参照完整性
  FOREIGN   KEY（Cno）REFERENCES Course（Cno）-- 在表级定义参照完整性
  )
```

‍

### 用户定义完整性

‍

1. 属性上的约束条件

    * 列值非空（NOTNULL）
    * 列值唯一（UNIQUE）
    * 检查列值是否满足一个条件表达式（CHECK短语）
2. 元组上的约束条件

‍

当学生的性别是男时，其名字不能以Ms.打头

```sql
CREATE TABLE Student
(Sno CHAR（9）,
  Sname CHAR（8）NOT NULL,
  Ssex CHAR（2）,
  Sage SMALLINT,
  Sdept CHAR（20）,
  PRIMARY KEY（Sno）,
  CHECK（Ssex='女'OR Sname NOT LIKE'Ms.%'）
);
-- 定义了元组中Sname和Ssex两个属性值之间的约束条件
```

‍

‍

### 完整性约束命名子句

‍

定义表上

```sql
Constraint 条件名 约束条件
```

‍

去除

```sql
Drop Contraint Student
```

‍

‍

### 断言

‍

‍

### 触发器

‍

‍

‍

‍

## 并发

‍

‍

### 多事务执行方式

‍

(1)事务串行执行

* 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
* 不能充分利用系统资源，发挥数据库共享资源的特点

‍

(2)交叉并发方式（interleaved concurrency）

* 事务的并行执行是这些并行事务的并行操作轮流交叉运行
* 是单处理机系统中的并发方式，能够减少处理机的空闲时间，提高系统的效率

‍

(3)同时并发方式（simultaneous  concurrency）

* 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行
* 最理想的并发方式，但受制于硬件环境
* 更复杂的并发方式机制

‍

### 并发问题

* 丢失修改（lost update）

  * 丢失修改是指事务1与事务2从数据库中读入同一数据并修改
  * 事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。
* 不可重复读（non-repeatable read）

  * 不可重复读是指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。
* 读“脏”数据（dirty read）

  * 事务1修改某一数据，并将其写回磁盘
  * 事务2读取同一数据后
  * 事务1由于某种原因被撤消，这时事务1已修改过的数据恢复原值
  * 事务2读到的数据就与数据库中的数据不一致，
  * 是不正确的数据，又称为“脏”数据。

‍

‍

#### 并发控制机制的任务

略

* 保证事务的隔离性
* 保证数据库的一致性

‍

‍

### 封锁

封锁是实现并发控制的一个非常重要的技术

就是事务T在对某个数据对象（例如表、记录等）操作之前先向系统发出请求，对其加锁

加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象

‍

‍

#### 类型

‍

* 排它锁（eXclusive lock，X锁）

  * 写锁
  * 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
* 共享锁（Share lock，S锁）

  * 读锁
  * 若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁

‍

‍

#### 基本锁的相容矩阵

Y相容 N不相容

‍

**X - X 不相容 X - S 不相容, S - S 相容**

‍

‍

‍

### 封锁协议

‍

#### 1级封锁协议

事务T在==修改==数据R之前必须先对其加==X锁==，直到**事务结束才释放**

‍

* 1级封锁协议可防止丢失修改
* 在1级封锁协议中，如果是读数据，不需要加锁的，所以它不能保证可重复读和不读“脏”数据。

  * 读“脏”数据
  * 不可重复读

‍

#### 2级封锁协议

1级封锁协议 + 事务T在==读取==数据R前必须先加==S锁==，**读完后即可释放S锁**

‍

* 2级封锁协议可以防止丢失修改和读“脏”数据。
* 在2级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读

‍

#### 3级封锁协议

1级封锁协议 + 事务T在==读取==数据R之前必须先对其加==S锁==，**==直到事务结束==**​**才释放**

‍

* 3级封锁协议可防止丢失修改、读脏数据和不可重复读。

‍

### 活锁和死锁

‍

#### 活锁

饥饿. 一个事务等待时间太长，似乎被锁住了，实际上可能被激活

‍

解决办法:先来先服务的策略,类比操作系统的FCFS调度算法

‍

‍

#### 死锁

简而言之就是,多个事物之间互相请求对方的资源而等待,导致永不结束

‍

死锁的诊断与解除

1. 与操作系统类似，一般使用**超时法**或**事务等待图**法。
2. DBMS**并发控制子系统检测到死锁后**，就要设法解除。通常采用的方法是**选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行下去**

‍

‍

### 并发调度的可串行性

‍

#### 可串行化调度

什么样的并发调度是正确调度? **可串行化的调度**

多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化（serializable）调度

‍

‍

#### 冲突可串行化调度

略

‍

‍

### 两段锁协议

指所有事务必须分两个阶段对数据项加锁和解锁

* **扩展阶段**
* **收缩阶段**

‍

* 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；
* 在释放一个封锁之后，事务不再申请和获得任何其他封锁。

‍

“两段”锁的含义是事务分为两个阶段:

1. 第一阶段是获得封锁，也称为扩展阶段，在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
2. 第二阶段是释放封锁，也称为收缩阶段，在这个阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁

‍

‍

### 封锁粒度

**封锁的大小**称为封锁的粒度

封锁粒度与系统的并发度和并发控制的开销密切相关：

* 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；
* 封锁的粒度越小，并发度较高，但系统开销也就越大

‍

选择封锁粒度：

* 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
* 需要处理大量元组的用户事务：以关系为封锁单元
* 只处理少量元组的用户事务：以元组为封锁单位

‍

#### 多粒度封锁

在一个系统中同时支持多种封锁粒度供事务选择

多粒度树中，根节点是整个数据库，表示最大的数据粒度。叶节点是最小的，如元组、属性值

在多粒度封锁中，一个数据对象能被分为显式封锁（本身直接加锁）和隐式封锁（上级结点加锁）

‍

‍

#### 意向锁

略

‍

在上述多粒度封锁中，对某个数据加锁要检查数据对象本身、上级、下级结点的封锁情况，为了提高检查效率采用意向锁

对一个结点加意向锁，说明该结点下层正在加锁

对任一结点加锁，必须先对其上层结点加意向锁

①意向共享锁（IS）

表示该结点的后裔结点拟（意向）加S锁

②意向排它锁（IX）

表示该节点的后裔结点拟（意向）加X锁

③共享意向排它锁（SIX=S+IX）

表示对其本身加S锁，再加IX表示后裔结点拟加X锁

‍

##### 锁的强度

指对其他锁的排斥程度

一个事务在申请封锁时，以强锁代替弱锁是安全的，反之不然。

强度排序：

X > SIX > S / IX > IS

‍

‍

‍
