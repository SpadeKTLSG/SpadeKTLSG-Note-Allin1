-- 精心烘焙的Linux指令手册

‍

### Header

个人命令等查阅本

改编自<决战linux之巅>的总结, 原文[CSDN](https://blog.csdn.net/as604049322/article/details/120446586)

‍

‍

# 知识

‍

## 版本

‍

### 内核版本

内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层.   

Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环

[内核源码网址](http://www.kernel.org)

所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中. 

‍

‍

### 发行版本

Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件

目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、 SolusOS 等

‍

‍

‍

## 目录结构

‍

/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录. 所有的东西都是从这里开始. 当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录.   

‍

/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等.   

/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub.   

/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt.   

/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d. 

‍

/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，`~`​表示当前用户的家目录<sub>， </sub>​`~edu`​ 表示用户 edu 的家目录. 

/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助.   

/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下.   

‍

/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载.   

/opt：给主机额外安装软件所摆放的目录.   

/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等.   

/run：存放到目前为止的所有运行信息

/root：系统管理员root的家目录.   

/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等. 与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能"查看"而不能设置和使用.   

/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下.   

/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内.   

/sys：系统硬件信息相关的文件

/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件. /usr/local: 存放软件升级包. /usr/share/doc: 系统说明文件存放目录. /usr/share/man: 程序说明文件存放目录.   

/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下. 

/home/user: 称之为用户工作目录或家目录(~)

‍

每个目录下都有.和..  

. 表示当前目录  
.. 表示上一级目录，即父目录  

根目录下的.和..都表示当前目录

‍

‍

## 进程管理

‍

### 查看进程

ps 指令：查看某个时间点的进程信息

top 指令：实时显示进程信息

pstree：查看进程树

```bash
pstree -A	#查看所有进程树
```

---

### 进程 ID

进程号：

* 进程号为 0 的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程
* 进程号为 1 是 init 进程，是一个守护进程，在自举过程结束时由内核调用，init 进程绝不会终止，是一个普通的用户进程，但是它以超级用户特权运行

父进程 ID 为 0 的进程通常是内核进程，作为系统**自举过程**的一部分而启动，init 进程是个例外，它的父进程是 0，但它是用户进程

* 主存 = RAM + BIOS 部分的 ROM
* DISK：存放 OS 和 Bootloader
* BIOS：基于 I/O 处理系统
* Bootloader：加载 OS，将 OS 放入内存

自举程序存储在内存中 ROM，**用来加载操作系统**，初始化 CPU、寄存器、内存等。CPU 的程序计数器指自举程序第一条指令，当计算机**通电**，CPU 开始读取并执行自举程序，将操作系统（不是全部，只是启动计算机的那部分程序）装入 RAM 中，这个过程是自举过程。装入完成后程序计数器设置为 RAM 中操作系统的**第一条指令**，接下来 CPU 将开始执行（启动）操作系统的指令

存储在 ROM 中保留很小的自举装入程序，完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C 盘）

---

### 进程状态

|状态|说明|
| ------| -------------------------------------------------------------------------------------------------------------------------------|
|R|running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中|
|D|uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞|
|S|interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成|
|Z|zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息|
|T|stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪|

孤儿进程：

* 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程
* 孤儿进程将被 init 进程所收养，并由 init 进程对它们完成状态收集工作，所以孤儿进程不会对系统造成危害

僵尸进程：

* 一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程
* 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）
* 系统所能使用的进程号是有限的，产生大量僵尸进程，会导致系统没有可用的进程号而不能产生新的进程
* 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程

补充：

* 守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。
* 守护进程是**脱离于终端**并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断
* 很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭；另一些只在需要的时候才启动，完成任务后就自动结束

---

### 状态改变

‍

#### SIGCHLD

当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：

* 得到 SIGCHLD 信号
* waitpid() 或者 wait() 调用会返回

子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等；在子进程退出时进程描述符不会立即释放，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息，释放子进程的 PCB

---

#### wait

```c
pid_t wait(int *status)
```

参数：status 用来保存被收集的子进程退出时的状态，如果不关心子进程**如何**销毁，可以设置这个参数为 NULL

父进程调用 wait() 会阻塞等待，直到收到一个子进程退出的 SIGCHLD 信号，wait() 函数就会销毁子进程并返回

* 成功，返回被收集的子进程的进程 ID
* 失败，返回 -1，同时 errno 被置为 ECHILD（如果调用进程没有子进程，调用就会失败）

---

#### waitpid

```c
pid_t waitpid(pid_t pid, int *status, int options)
```

作用和 wait() 完全相同，只是多了两个可控制的参数 pid 和 options

* pid：指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号；如果 pid=-1 时，那么和 wait() 作用相同，都是关注所有子进程退出的 SIGCHLD 信号
* options：主要有 WNOHANG 和 WUNTRACED 两个，WNOHANG 可以使 waitpid() 调用变成非阻塞的，就是会立即返回，父进程可以继续执行其它任务

‍

# 指令

‍

Linux命令格式： []代表可选

```linux
command  [-options]  [parameter1]  …
```

command: 命令名；

[-options]：选项,可用来对命令进行控制，也可以省略，

parameter1 …：传给命令的参数：可以是零个一个或多个

‍

  

## 终端操作

‍

### 帮助获取

‍

#### **help**

一般是linux命令自带的帮助信息

```linux
ls --help
```

‍

#### **man(manual)**

linux提供的一个手册，包含了绝大部分的命令、函数使用说明; 手册分成很多章节（section），使用man时可以指定不同的章节来浏览. 

```git
man ls ; man 2 printf
```

‍

man中各个section意义如下：

1. Standard commands（标准命令）
2. System calls（系统调用，如open,write）
3. Library functions（库函数，如printf,fopen）
4. Special devices（设备文件的说明，/dev下各种设备）
5. File formats（文件格式，如passwd）
6. Games and toys（游戏和娱乐）
7. Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）
8. Administrative Commands（管理员命令，如ifconfig）

‍

man是按照手册的章节号的顺序进行搜索的.   
man设置了如下的功能键：

注意：实际上，我们不用指定第几个章节也用查看，如，man ls

|功能键|功能|
| ---------| ----------------------|
|空格键|显示手册页的下一屏|
|Enter键|一次滚动手册页的一行|
|b|回滚一屏|
|f|前滚一屏|
|q|退出man命令|
|h|列出所有功能键|
|/word|搜索word字符串|

‍

‍

### 历史记录

当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来

history保留了最近执行的命令记录，默认可以保留1000. 历史清单从0开始编号到最大值. 

历史清单从0开始编号到最大值. 

```linux
history N       显示最近N条命令
history -c      清除所有的历史记录
history -w  xxx.txt 保存历史记录到文本xxx.txt
```

‍

### Ctrl组合键

‍

|Ctrl+c|结束正在运行的程序|
| :------: | :------------------------: |
|Ctrl+d|结束输入或退出shell|
|Ctrl+s|暂停屏幕输出【锁住终端】|
|Ctrl+q|恢复屏幕输出【解锁终端】|
|Ctrl+L|清屏，等同于Clear|

‍

|ctrl+a|当前光标到行首|
| :------: | :------------------: |
|ctrl+e|当前光标到行尾|
|ctrl+u|删除当前光标到行首|
|ctrl+k|删除当前光标到行尾|

‍

|Ctrl+y|在光标处粘贴剪切的内容|
| :--------: | :----------------------------------------------------: |
|Ctrl+r|查找历史命令【输入关键字，就能调出以前执行过的命令】|
|Ctrl+t|调换光标所在处与其之前字符位置，并把光标移到下个字符|
|Ctrl+x+u|撤销操作|
|Ctrl+z|转入后台运行|

‍

‍

‍

## 权限管理

‍

用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限

通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限. 

R W X

* 读权限（r） ：对于文件，具有读取文件内容的权限；对于目录，具有浏览目录的权限.
* 写权限（w） ：对于文件，具有修改文件内容的权限；对于目录，具有删除、移动目录内文件的权限.
* 可执行权限（x）： 对于文件，具有执行文件的权限；对于目录，该用户具有进入目录的权限.

‍

‍

### 显示

‍

#### stat

‍

显示inode的内容

‍

#### lsattr

查看特殊权限

```python
# lsattr /etc/passwd
```

‍

### 改变

‍

#### chmod

修改文件权限

两种使用格式：字母法与数字法

字母法：chmod u/g/o/a +/-/= rwx 文件

‍

[ u/g/o/a ]

* u    user 所有者
* g    group 用户组
* o    other 表示其他以外的人
* a    all 表示这三者皆是

‍

[ + - = ]

* +增加权限
* -撤销权限
* =设定权限

‍

rwx

* r    read 表示可读取，没有意味着不能通过ls查看这个目录的内容
* w    write 表示可写入，没有意味着不能在目录下创建新的文件
* x    excute 表示可执行，没有意味着不能通过cd进入这个目录

‍

* user 属主权限
* group 属组权限
* others 其他权限
* all 全部的身份

‍

数字法：“rwx” 这些权限也可以用数字来代替

* r    读取权限     "4"
* w    写入权限     "2"
* x    执行权限     "1"
* -     无权限       "0"

各权限的数字对照表：[r]:4、[w]:2、[x]:1、[-]:0

> 例如权限为：[-rwxrwx---] 分数是
>
> * owner = rwx = 4+2+1 = 7
> * group = rwx = 4+2+1 = 7
> * others= --- = 0+0+0 = 0
>
> 表示为：`chmod -R 770 文件名`​

```python
如执行：chmod u=rwx,g=rx,o=r filename 就等同于：chmod u=7,g=5,o=4 filename
chmod 777 file：所有用户拥有读、写、执行权限

如果想递归所有目录加上相同权限，需要加上参数“ -R ”
chmod 777 test/ -R 递归 test 目录下所有文件加 777 权限
```

‍

**文件和目录权限的区别：**

对文件和目录而言，读写执行表示不同的意义。

‍

对于文件：

|权限名称|可执行操作|
| ----------| -----------------------------|
|r|可以使用 cat 查看文件的内容|
|w|可以修改文件的内容|
|x|可以将其运行为二进制文件|

‍

对于目录：

|权限名称|可执行操作|
| ----------| --------------------------|
|r|可以查看目录下列表|
|w|可以创建和删除目录下文件|
|x|可以使用 cd 进入目录|

‍

#### chown

修改文件所有者

‍

‍

#### chgrp

修改文件所属组

‍

‍

#### chattr

设置特殊权限

凌驾于r、w、x、suid、sgid之上的权限. 

‍

* -i    锁定文件，不能编辑，不能修改，不能删除，不能移动，可以执行
* -a    仅可以追加文件，不能编辑，不能删除，不能移动，可以执行

‍

‍

### 特殊

‍

linux共12位权限，除了9位基础权限还有3个特殊权限

‍

#### setUID(suid)

‍

命令功能： 临时使用命令的属主权限执行该命令. 即如果文件有suid权限时，那么普通用户去执行该文件时，会以该文件的所属用户的身份去执行. 

SetUID（简写suid）：会在属主权限位的执行权限上写个s.  如果该属主权限位上有执行权限，则会在属主权限位的执行权限上写个s（小写）； 如果该属主权限位上没有执行权限，则会在属主权限位的执行权限上写个S（大写）

‍

由于 passwd 具有s权限，普通用户使用该命令的时候，就会以该命令的属主身份root执行该命令，于是能够顺利修改

‍

普通用户不具备修改权限的 /etc/shadow 文件

希望普通用户user1可以删除某个自己没有权限删除的文件的操作方法：

* sudo给user1授权rm权限
* rm设置suid
* 修改被删除文件上级目录的权限

‍

**总结**

1. 让普通用户对可执行的二进制文件，临时拥有二进制文件的属主权限
2. 如果设置的二进制文件没有执行权限，那么suid的权限显示就是S（大写字母S）
3. 特殊权限suid仅对二进制可执行程序有效，其他文件或目录则无效
4. suid极其危险，如果给vim或者rm命令设置了setUID，那么任何文件都能编辑或者删除了，相当于有root权限了

‍

‍

#### setGID(sgid)

‍

命使得多个用户之间共享一个目录的所有文件变得简单. 

当某个目录设置了sgid后，在该目录中新建的文件不在是创建该文件的默认所属组. 

‍

如果该属组权限位上有执行权限，则会在属组主权限位的执行权限上写个s（小写字母）； 如果该属组权限位上没有执行权限，则会在属组主权限位的执行权限上写个S（大写字母S）. 

‍

‍

‍

‍

### 预设

‍

#### sticky(sbit)

粘滞位

‍

只对目录有效，对某目录设置粘滞位后，普通用户就算有w权限也只能删除该目录下自己建立的文件，而不能删除其他用户建立的文件

如果该其他用户权限位上有执行权限，则会在其他用户权限位的执行权限上写个t（小写）；如果该其它用户权限位上没有执行权限，则会在其他用户权限位的执行权限上写个T（大写）

系统中存在的/tmp目录是经典的粘滞位目录，谁都有写权限，因此安全成问题，常常是木马第一手跳板. 

‍

#### umask

掩码

用于设置用户在创建文件时的默认权限，当我们在系统中创建目录或文件时，目录或文件所具有的默认权限就是由umask值决定的. 

对于root用户，系统默认的umask值是0022；对于普通用户，系统默认的umask值是0002. 执行umask命令可以查看当前用户的umask值. 

‍

**改变新文件的权限**

umask值一共有4组数字，其中第1组数字用于定义特殊权限，一般不予考虑，与一般权限有关的是后3组数字. 

默认情况下，对于目录，用户所能拥有的最大权限是777；对于文件，用户所能拥有的最大权限是目录的最大权限去掉执行权限，即666. 因为x执行权限对于目录是必须的，没有执行权限就无法进入目录，而对于文件则不必默认赋予x执行权限. 

对于root用户，他的umask值是022. 当root用户创建目录时，默认的权限就是用最大权限777去掉相应位置的umask值权限，即对于所有者不必去掉任何权限，对于所属组要去掉w权限，对于其他用户也要去掉w权限，所以目录的默认权限就是755；当root用户创建文件时，默认的权限则是用最大权限666去掉相应位置的umask值，即文件的默认权限是644. 

通过umask命令可以修改umask值，比如将umask值设为0077

‍

**永久修改umask**

umask命令只能临时修改umask值，系统重启之后umask将还原成默认值. 如果要永久修改umask值，可修  
改 /etc/bashrc 或 /etc/profile 文件. 

例如要将默认umask值设置为027，那么可以在文件中增加一行 umask 027

‍

‍

## 文件管理

‍

* cat    由第一行开始显示文件内容
* tac    从最后一行开始显示
* nl     显示的时候，顺道输出行号
* more    一页一页的显示文件内容
* less    与more 类似，但可以往前翻页
* head    只看头几行
* tail    只看尾巴几行

‍

### 显示

‍

#### cat-tac

基本显示

```python
cat [-AbEnTv]
```

/tac刚好相反

‍

* -A ：    相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
* -v ：    列出一些看不出来的特殊字符
* -E ：    将结尾的断行字节 $ 显示出来；
* -T ：    将 [tab] 按键以 ^I 显示出来；
* -b ：    列出行号，空白行不标行号
* -n ：    列出行号，连同空白行也会有行号

‍

‍

‍

### 分页

‍

#### nl

显示行号

```python
nl [-bnw] 文件
```

‍

* -b ：    指定行号指定的方式，主要有两种：  
  -b a ：    表示不论是否为空行，也同样列出行号(类似 cat -n)；  
  -b t ：    如果有空行，空的那一行不要列出行号(默认值)；
* -n ：    列出行号表示的方法，主要有三种：  
  -n ln ：    行号在荧幕的最左方显示；  
  -n rn ：    行号在自己栏位的最右方显示，且不加 0 ；  
  -n rz ：    行号在自己栏位的最右方显示，且加 0 ；
* -w ：    行号栏位的占用的位数.

‍

‍

#### more-less

分屏显示

‍

More

* Space    向下翻一页；
* Enter    向下翻『一行』；
* /字串    在这个显示的内容当中，向下搜寻『字串』这个关键字；
* :f    立刻显示出档名以及目前显示的行数；
* q    离开
* b 或 [ctrl]-b    代表往回翻页，不过这动作只对文件有用，对管线无用.

‍

Less

* 空白键    向下翻动一页；
* [pagedown]    向下翻动一页；
* [pageup]    向上翻动一页；
* /字串     向下搜寻『字串』的功能；
* ?字串     向上搜寻『字串』的功能；
* n         重复前一个搜寻 (与 / 或 ? 有关！)
* N         反向的重复前一个搜寻 (与 / 或 ? 有关！)
* q         离开

‍

‍

#### head-tail

取首/尾n行

‍

```python
head [-n number] 文件
```

* -n ：    后面接数字，代表显示几行

‍

```python
tail [-n number] 文件
```

* -n ：后面接数字，代表显示几行的意思
* -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测

‍

‍

### 创建

‍

1. 使用touch命令
2. 使用vi和vim命令
3. 使用>、>>命令
4. 使用cp命令
5. 使用cat命令间接

‍

#### touch

‍

同时创建两个

​`touch XXX, XXX`​

‍

批量创建文件

​`touch test{01..10}.sh`​

‍

更改文件 test.sh时间为当前时间（test.sh已存在）

​`touch test.sh`​

‍

‍

#### **vi/vim**

使用编辑器打开

```bash
vi test.sh

vim test.sh
```

‍

‍

#### ls + \>、\>\>

输出重定向将结果写入文件

可将本应显示在终端上的内容保存到指定文件中.  如：ls > test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )

‍

> 单箭头输出重定向会覆盖原来的内容，>>输出重定向则会追加到文件的尾部.

‍

‍

#### grep

将结果写入文件

```python
ps -ef | grep java > test.sh
ps -ef | grep java >> test.sh
```

‍

‍

#### echo

将结果写入文件

```python
echo $PATH > test.sh
echo $PATH >> test.sh
```

‍

#### ln

建立链接文件

软链接：ln -s 源文件 链接文件

硬链接：ln 源文件 链接文件

‍

软链接(常用)类似于Windows下的快捷方式，如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径

硬链接只能链接普通文件不能链接目录.  两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在

‍

---

‍

### 目录

**Linux所有的目录和文件名大小写敏感**

* **绝对路径：**   
  路径的写法，由根目录  **/**  写起，例如： /usr/share/doc 这个目录.
* **相对路径：**   
  路径的写法，不是由  **/**  写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： **cd ../man** 这就是相对路径的写法.

‍

* ls（英文全拼：list files）: 列出目录及文件名
* cd（英文全拼：change directory）：切换目录
* pwd（英文全拼：print work directory）：显示目前的目录
* mkdir（英文全拼：make directory）：创建一个新的目录
* rmdir（英文全拼：remove directory）：删除一个空的目录
* cp（英文全拼：copy file）: 复制文件或目录
* rm（英文全拼：remove）: 删除文件或目录
* mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称

‍

‍

#### ls

列出目录的内容

‍

Linux文件或者目录名称最长可以有265个字符,“.”代表当前目录，“..”代表上一级目录,以“.”开头的文件为隐藏文件需要用 -a 参数才能显示. 

```
ls [-aAdfFhilnrRSt] 目录名称
ls [--color={never,auto,always}] 目录名称
ls [--full-time] 目录名称
```

* -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)
* -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)
* -l ：长数据串列出，包含文件的属性与权限等等数据(常用) 直接用ll

‍

‍

**==列出的信息的含义==**

文件类型(1) + 权限3组(9) + 目录/链接个数 + 所有者以及组 + 大小 + 修改日期 + 名称 + (*)

‍

**第1个字母**代表文件的类型

* “d” 代表文件夹
* “-” 代表普通文件
* “c” 代表硬件字符设备
* “b” 代表硬件块设备
* “s” 表示管道文件
* “l” 代表软链接文件.

‍

**后9个字母**分别代表三组权限

第一段表示文件创建者/所有者对该文件所具有的权限，第二段表示创建者/所有者所在的组的其他用户所具有的权限，第三段表示其他组的其他用户所具有的权限. 

‍

r（Read，读取权限）：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限.   
w（Write，写入权限）：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限.   
x（eXecute，执行权限）：对文件而言，具有执行文件的权限；对目录来说，该用户具有进入目录的权限. 

‍

2个很特殊的属性

s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源. 请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用. 

t或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件.   
综合起来可得，对于back_init文件，其创建者/所有者具有可读可写可执行的权限，其创建者/所有者所在的组的其他用户具有可读可写可执行的权限，其他组的其他用户则具有可读可执行但不可写的权限. 

‍

再然后**一个**是目录/链接个数

对于目录文件，表示它的第一级子目录的个数. 注意此处看到的**值要减2**才等于该目录下的子目录的实际个数(要加上.目录和..目录)

‍

**之后一对**

所有者及组

文件的所有者/创建者（owner）及其所在的组（group）

‍

**数值**

文件大小,单位为字节.   
如果是目录，则表示该目录符所占的大小，并不表示该目录下所有文件的大小

‍

**修改日期**

最后修改的日期时间

‍

**文件名称 字体颜色**

在大多数的linux shell窗口中，还能用颜色来区分不同文件的属性

|文件的颜色|含义|
| :----------: | :----------: |
|蓝色|目录|
|绿色|可执行文件|
|红色|压缩文件|
|浅蓝色|链接文件|
|灰色|其他文件|

‍

**另**

凡是文件名后面带了一个星号（*）的，都是在说明这是一个可执行文件

‍

‍

|通配符|含义|
| --------| -----------------------------------------------|
|*|所有字符|
|?|任意字符|
|X* */** X|查找...开头/结尾的|
|X?/?X|查找..位置字符任意,...开头结尾的|
|[ ]|匹配字符组中的任意一个  里面配合 - 来表示范围|
|\\|转义字符|

‍

‍

#### cd

(切换目录)

Change Directory

​​

```
 cd [相对路径或绝对路径]
```

* cd      == cd ~
* cd ~    切换到当前用户的主目录(/home/用户目录)
* cd .    切换到当前目录
* cd ..   切换到上级目录
* cd -    进入上次所在的目录

‍

```
#使用 mkdir 命令创建 runoob 目录
[root@www ~]# mkdir runoob

#使用绝对路径切换到 runoob 目录
[root@www ~]# cd /root/runoob/

#使用相对路径切换到 runoob 目录
[root@www ~]# cd ./runoob/

# 表示回到自己的家目录，亦即是 /root 这个目录
[root@www runoob]# cd ~

# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；
[root@www ~]# cd ..
```

‍

#### pwd

(显示目前所在的目录)显示当前路径

**Print Working Directory**  显示目前所在目录的命令

```
[root@www ~]# pwd [-P]
```

*  **-P** ：显示出确实的路径，而非使用链接 (link) 路径.

‍

实例：单纯显示出目前的工作目录：

```
[root@www ~]# pwd
/root   <== 显示出目录啦～
```

‍

实例显示出实际的工作目录，而非链接档本身的目录名而已. 

```
[root@www ~]# cd /var/mail   <==注意，/var/mail是一个链接档
[root@www mail]# pwd
/var/mail         <==列出目前的工作目录

[root@www mail]# pwd -P
/var/spool/mail   <==怎么回事？有没有加 -P 差很多～

[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -> spool/mail
# 看到这里应该知道为啥了吧？因为 /var/mail 是链接档，链接到 /var/spool/mail 
# 所以，加上 pwd -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！
```

‍

‍

#### mkdir

make directory创建目录

‍

```
mkdir [-mp] 目录名称
```

‍

新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限

‍

* -m ：    指定被创建目录的权限，而不是根据默认权限 (umask) 设定
* -p ：    递归创建所需要的目录

‍

```python
//递归创建实例:
mkdir -p test1/test2/test3/test4

//指定被创建目录的权限
mkdir t2 -m 711
```

‍

#### rm

删除文件或目录

==rm -fr 包治百病==

‍

文件删除后不能恢复

为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件

```java
rm -fr 包治百病
```

‍

* -i    以进行交互式方式执行
* -f    强制删除，忽略不存在的文件，无需提示
* -r    递归地删除目录下的内容，删除文件夹时必须加此参数

‍

‍

#### rmdir

删除空目录

```
 rmdir [-p] 目录名称
```

*  **-p ：** 从该目录起，一次删除多级空目录

这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录

‍

‍

#### cp

复制文件或目录

```
# cp [-adfilprsu] 来源档(source) 目标档(destination)
# cp [options] source1 source2 source3 .... directory
```

‍

*  **-a    ** 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性.
*  **-d    ** 若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；
*  **-f    ** 为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
*  **-i    ** 交互式复制，在覆盖目标文件之前将给出提示要求用户确认
*  **-l    ** 进行硬式链接(hard link)的链接档创建，而非复制文件本身；
*  **-p    ** 连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
*  **-r    ** 递归持续复制，用於目录的复制行为；(常用)
*  **-s    ** 复制成为符号链接档 (symbolic link)，亦即批量创建快捷方式
*  **-u    ** 若 destination 比 source 旧才升级 destination ！
*  **-v **    显示拷贝进度

‍

‍

‍

#### mv

移动文件或目录，也可以给文件或目录重命名

‍

* -f    禁止交互式操作，如有覆盖也不会给出提示
* -i    确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户  
  答以避免误覆盖文件
* -v    显示移动进度
* -u    若目标文件已经存在，且 source 比较新，才会升级 (update)

‍

‍

‍

### 搜索

‍

#### grep

强大的文本搜索工具，允许对文本文件进行模式查找

如果找到匹配模式，grep打印包含模式的所有行

```python
grep [-选项] '搜索内容串' 文件名
```

‍

* -r    递归的方式查找
* -v    打印出不符合条件行的内容

‍

grep命令中输入字符串参数时，最好引号或双引号括起来. 例如： grep 'a' 1.txt

‍

```python
在当前目录中，查找前缀有test字样的文件中包含 test 字符串的文件，并打印出该字符串的行：
grep test test* 

以递归的方式查找符合条件的文件:
查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串"update"的文件，并打印出该字符串所在行的内容
grep -r update /etc/acpi #以递归的方式查找“etc/acpi”

查找文件名中包含 test 的文件中不包含test 的行:
grep -v test*
```

‍

‍

#### find

查找文件

在指定目录下查找文件. 任何位于参数之前的字符串都将被视为欲查找的目录名

如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件并且将查找到的子目录和文件全部显示

```python
find path -option [ -print ] [ -exec -ok command ] {} \;
```

‍

* -perm xxxx    权限为 xxxx的文件或目录
* -user    按照文件属主来查找文件.
* -size n     n单位,b:512位元组的区块,c:字元数,k:kilo bytes,w:二个位元组
* -mount, -xdev     只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件
* -amin n    在过去 n 分钟内被读取过
* -anewer file    比文件 file 更晚被读取过的文件
* -atime n    在过去n天内被读取过的文件
* -cmin n    在过去 n 分钟内被修改过
* -cnewer file    比文件 file 更新的文件
* -ctime n    在过去n天内被修改过的文件
* -empty    空的文件
* -gid n or -group name    gid 是 n 或是 group 名称是 name
* -ipath p, -path p    路径名称符合 p 的文件，ipath 会忽略大小写
* -name name, -iname name    文件名称符合 name 的文件. iname 会忽略大小写
* -type    查找某一类型的文件：

  b - 块设备文件  
  d - 目录  
  c - 字符设备文件  
  p - 管道文件  
  l - 符号链接文件  
  f - 普通文件
* -exec 命令名{} \ (注意：“}”和“\”之间有空格)

‍

实例

```python
显示当前目录中大于20字节并以.c结尾的文件名
find . -name "*.c" -size +20c

将目前目录其其下子目录中所有一般文件列出
find . -type f

将目前目录及其子目录下所有最近 20 天内更新过的文件列出
find . -ctime -20

查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：
find /var/log -type f -mtime +7 -ok rm {} \;

查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：
find . -type f -perm 644 -exec ls -l {} \;

查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：
find / -type f -size 0 -exec ls -l {} \;

从根目录查找类型为符号链接的文件，并将其删除：
find / -type l -exec rm -rf {} \

从当前目录查找用户tom的所有文件并显示在屏幕上
find . -user tom

在当前目录中查找所有文件以.doc结尾，且更改时间在3天以上的文件，找到后删除，并且给出删除提示
find . -name *.doc  -mtime +3 -ok rm {} \;

在当前目录下查找所有链接文件，并且以长格式显示文件的基本信息
find . -type l -exec ls -l {} \;

在当前目录下查找文件名有一个小写字母、一个大写字母、两个数字组成，且扩展名为.doc的文件
find . -name '[a-z][A-Z][0-9][0-9].doc'
```

‍

#### locate

查找

locate命令会去保存文档和目录名称的数据库内，查找文件或目录. 

‍

* -d或--database=     配置locate指令使用的数据库. locate指令预设的数据库位于/var/lib/mlocate目录里，文档名为mlocate.db

‍

‍

locate与find的区别: find 是去硬盘找，locate 只在/var/lib/slocate资料库中找. 

‍

locate的速度比find快，它并不是真的查找，而是查数据库，一般文件数据库在/var/lib/mlocate/mlocate.db中，所  
以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库(updatedb)

‍

‍

### 归档

‍

#### tar

归档管理

把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据. 

‍

```python
 tar [参数] 打包文件名 文件
```

tar命令参数很特殊，其参数前面可以使用“-”，也可以不使用

注意：除了f需要放在参数的最后，其它参数的顺序任意

* -c    生成档案文件，创建打包文件
* -v    列出归档解档的详细过程，显示进度
* -f    指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后
* -t    列出档案中包含的文件
* -x    解开档案文件
* -z    调用gzip实现压缩

‍

tar命令中-z选项可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程

```java
压缩用法：tar [zcvf] 压缩包包名 文件1 文件2 ...
```

```java
解压用法： tar [zxvf] 压缩包包名
```

‍

‍

#### gzip

bzip2

文件压缩解压

tar与gzip命令结合使用实现文件打包、压缩.  tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz

```python
gzip  [选项]  被压缩文件
```

* -d    解压文件
* -r    压缩文件

‍

bzip2命令跟gzip用法类似

‍

```java
压缩用法：tar jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *.c)
```

```java
解压用法：tar jxvf 压缩包包名 (tar jxvf bk.tar.bz2)
```

‍

‍

#### zip

unzip

文件压缩解压

‍

通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip

```git
压缩文件：zip [-r] 目标文件(没有扩展名) 源文件
```

```git
解压文件：unzip -d 解压后目录文件 压缩文件
```

‍

‍

‍

### 管道

|

管道命令是'|'，一个命令的输出可以通过管道做为另一个命令的输入, |的左右分为两端，从左端写入到右端通过它可以对数据进行连续处理

管道命令仅处理标准输出，对于标准错误输出，将忽略

管道命令右边命令，必须能够接收标准输入流命令才行，否则传递过程中数据会抛弃.   
常用来作为接收数据管道命令有： less,more,head,tail，而ls, cp, mv就不行

‍

‍

‍

#### 综合

‍

使用 ls、grep 和 wc 这三个命令来统计某个路径下文件或者文件夹的数量. 例如：

* 统计当前目录下文件的个数（不包括目录）：ls -l | grep "^-" | wc -l
* 统计当前目录下文件的个数（包括子目录）：ls -lR| grep "^-" | wc -l
* 查看某目录下文件夹 (目录)的个数（包括子目录）：ls -lR | grep "^d" | wc -l
* 统计当前文件夹下叫某某的文件的数量：find . -name filename | wc -l
* 统计当前文件夹下指定类型的文件的数量：find -name "*.js" | wc -l

‍

使用 find 命令获取所有文件，然后使用 wc 命令计算数量. 例如：

* 统计某个目录中的文件数（包括子目录）：find directory_path -type f | wc -l
* 递归统计出文件夹下所有文件的数目：find /path/to/folder -name "*.java" | wc -l
* 递归统计出文件夹下所有子文件夹的数目：find /path/to/folder -type d | wc -l

‍

‍

#### wc

统计字数

‍

可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则wc指令会从标准输入设  
备读取数据

‍

```python
wc [-lwm] [filename],[filename2],...
```

* -l:     统计行数
* -w：    统计英文单词
* -m：    统计字符数

默认的情况下，wc将计算指定文件的行数、字数，以及字节数

‍

示例

‍

#### cut

列选取命令

‍

* -d  ：    后面接分隔字符. 与 -f 一起使用；
* -f  ：    依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思；
* -c  ：    以字符 (characters) 的单位取出固定字符区间

cut以行为单位，根据分隔符把行分成若干列，这样就可以指定选取哪些列了

‍

示例

```python
cut -d '分隔字符' -f 选取的列数
echo $PATH|cut -d ':' -f 2      --选取第2列
echo $PATH|cut -d ':' -f 3,5    --选取第3列和第5列
echo $PATH|cut -d ':' -f 3-5    --选取第3列到第5列
echo $PATH|cut -d ':' -f 3-     --选取第3列到最后1列
echo $PATH|cut -d ':' -f 1-3,5  --选取第1到第3列还有第5列
```

‍

#### grep

行选取命令

```python
grep [-cinv] '查找的字符串' filename
```

在grep命令中输入字符串参数时，最好引号或双引号括起来. 例如： grep 'a' 1.txt

‍

* -v    显示不包含匹配文本的所有行（相当于求反）
* -n    显示匹配行及行号
* -i    忽略大小写
* -c    计算找到的行数

grep搜索内容串可以是正则表达式(略)

‍

实例

显示所有以“h”结尾的行  
​`grep h$`​

匹配所有以“a”开头且以“e”结尾的，中间包含2个字符的单词  
​`grep '<a..e>'`​

‍

#### sort

排序

```python
sort [-fbMnrtuk] [file or stdin]
```

‍

* -f  ：    忽略大小写的差异，例如 A 与 a 视为编码相同；
* -b  ：    忽略最前面的空格符部分；
* -M  ：    以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
* -n  ：    使用『纯数字』进行排序(默认是以文字型态来排序的)；
* -r  ：    反向排序；
* -u  ：    就是 uniq ，相同的数据中，仅出现一行代表；
* -t  ：    分隔符，默认是用 [tab] 键来分隔；
* -k  ：    以哪个区间 (field) 来进行排序

‍

默认是以第一个字符升序排序:

```python
# cat /etc/passwd | sort
```

以第3列排序：

```python
cat /etc/passwd | sort -t ':' -k 3
```

使用数字排序：

```python
cat /etc/passwd | sort -t ':' -k 3n  
```

倒序排序：

```python
cat /etc/passwd | sort -t ':' -k 3nr
```

‍

‍

#### uniq

去重

‍

* -i  ：    忽略大小写字符的不同；
* -c  ：    进行计数
* -u  ：    只显示唯一的行

该命令用于排完序之后，对排序结果进行去重

‍

```python
$ last | cut -d ' ' -f 1  | sort | uniq
```

‍

示例

```python
排序之后删除了重复行，同时在行首位置输出该行重复的次数：
#sort testfile | uniq -c

仅显示存在重复的行，并在行首显示该行重复的次数：
#sort testfile | uniq -dc
```

‍

‍

#### tee

同时输出多个文件

从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件. 

‍

一般情况下用重定向实现，需要同时输出多个文件时可以使用该命令. 

‍

-a或--append  附加到既有文件的后面，而非覆盖它

‍

‍

#### tr

替换指定的字符

不指定参数时，即表示替换指定的字符为另一个字符，支持指定的字符集合

‍

* -d, --delete：删除指定的字符
* -s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符

‍

示例

```python
将文件testfile中的小写字母全部转换成大写字母
cat testfile |tr a-z A-Z
或
cat testfile |tr [:lower:] [:upper:]

删除指定的字符：
$ cat t|tr -d 'dv'
```

‍

#### join

文件按行连接

‍

将两个文件中指定栏位相同的行连接起来. 即按照两个文件中共同拥有的某一列，将对应的行拼接成一行

注意：在使用join之前所处理的文件要事先经过排序

‍

‍

#### paste

将多个文件对应行链接在一起

```python
paste [-s][-d <间隔字符>][文件...]
```

‍

-d<间隔字符>或--delimiters=<间隔字符>  用指定的间隔字符取代跳格字符. 

-s或--serial  串列进行而非平行处理. 

[文件…] 指定操作的文件路径

‍

‍

#### split

文件切割

‍

该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件

‍

* -<行数> : 指定每多少行切成一个小文件
* -b<字节> : 指定每多少字节切成一个小文件
* -C<字节> : 与参数"-b"相似，但是在切 割时将尽量维持每行的完整性
* [输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号

‍

#### xargs

参数代换

‍

不是所有的命令都支持管道，如ls，对于不支持管道的命令，可以通过xargs让其有管道命令的效果

xargs 用作替换工具，读取输入数据重新格式化后输出

‍

‍

‍

‍

## 用户管理

‍

用户管理包括用户与组账号的管理

在Unix/Linux系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限.   

Unix/Linux系统中的root账号通常用于系统的维护和管理，它对Unix/Linux操作系统的所有部分具有不受限制的访问权限.   

在Unix/Linux安装的过程中，系统会自动创建许多用户账号，而这些默认的用户就称为“标准用户”.   
在大多数版本的Unix/Linux中，都不推荐直接使用root账号登录系统. 

‍

实现用户账号的管理，要完成的工作主要有如下几个方面：

* 用户账号的添加、删除与修改.
* 用户口令的管理.
* 用户组的管理.

‍

‍

### 用户

‍

#### whoami

查看当前用户

查看当前系统当前账号的用户名. 可通过cat /etc/passwd查看系统用户信息

‍

#### who

查看登录用户

‍

who命令用于查看当前所有登录系统的用户信息

‍

* -m或am I    只显示运行who命令的用户名、登录终端和登录时间
* -q或--count    只显示用户的登录账号和登录用户的数量
* -u        在登录时间后显示该用户最后一次操作到当前的时间间隔
* -u或--heading    显示列标题

‍

‍

#### exit    

退出登录账户

```python
如果是图形界面，退出当前终端；
如果是使用ssh远程登录，退出登陆账户；
如果是切换后的登陆用户，退出则返回上一个登陆账号。
```

‍

‍

#### useradd

添加用户账号

‍

在Unix/Linux中添加用户账号可以使用adduser或useradd命令，因为adduser命令是指向useradd命令的一个链接，因此，这两个命令的使用格式完全一样. 

```python
useradd [参数] 新建用户账号
```

‍

* -c comment 指定一段注释性描述.
* -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录.
* -g 用户组 指定用户所属的用户组.
* -G 用户组，用户组 指定用户所属的附加组.
* -s Shell文件 指定用户的登录Shell.
* -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号.

‍

相关说明

Linux每个用户都要有一个主目录，主目录就是第一次登陆系统，用户的默认当前目录(/home/用户)；  

每一个用户必须有一个主目录，所以用useradd创建用户的时候，一定给用户指定一个主目录；  

如果创建用户的时候，不指定组名，那么系统会自动创建一个和用户名一样的组名.   

若创建用户时未指定家目录，后期可通过 usermod -d /home/abc abc 指定

‍

```python
useradd -d /home/abc abc -m
创建abc用户，如果/home/abc目录不存在，就自动创建这个目录，同时用户属于abc组

useradd -d /home/a a -g test -m
创建一个用户名字叫a，主目录在/home/a，如果主目录不存在，就自动创建主目录，同时用户属于test组

cat /etc/passwd
查看系统当前用户名

useradd -s /bin/sh -g group –G adm,root gem

此命令新建了一个用户gem，该用户的登录Shell是 `/bin/sh`，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。

这里可能新建组：`#groupadd group及groupadd adm`

增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。
```

‍

‍

‍

#### usermod

修改用户

‍

常用的选项包括 -c, -d, -m, -g, -G, -s, -u以及-o等 ，这些选项的意义与 useradd 命令中的选项一样，可以为用户指定新的资源值

‍

* usermod -g 用户组 用户名    修改用户所在组
* usermod -d 家目录 用户名    改用户的家目录位置

‍

另外，有些系统可以使用选项：-l 新用户名

这个选项指定一个新的账号，即将原来的用户名改为新的用户名. 

‍

例如：

```
# usermod -s /bin/ksh -d /home/z –g developer sam
```

此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer. 

‍

‍

#### userdel

删除用户: 将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录. 

删除abc用户，但不会自动删除用户的主目录

‍

```python
userdel [-r]  用户名  
```

-r 用户名       删除用户，同时删除用户的主目录

‍

‍

#### passwd

设置用户密码

超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令

```python
passwd [选项] 用户名
```

‍

* -l     锁定口令，即禁用账号.
* -u     口令解锁.
* -d     使账号无口令. 这样用户下一次就不再允许了
* -f     强迫用户下次登录时修改口令.

‍

普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令. 

‍

‍

‍

‍

#### su

切换用户

‍

* su        切换到root用户
* su root    切换到root用户
* su -        切换到root用户，同时切换目录到/root
* su - root    切换到root用户，同时切换目录到/root
* su  普通用户           切换到普通用户
* su -  普通用户       切换到普通用户，同时切换普通用户所在的目录

‍

su后面可以加“-”会将当前的工作目录自动转换到切换后的用户主目录

‍

‍

#### sudo

以root身份执行指令

sudo命令可以临时获取root权限  
使用权限：在 /etc/sudoers 中有出现的使用者

‍

sudoers文件配置语法    

```python
user  MACHINE=COMMANDS
用户 登录的主机=（可以变换的身份） 可以执行的命令
```

‍

‍

### 组管理

‍

#### groupadd

添加、删除组账号

‍

cat /etc/group 查看用户组

‍

#### groupmod

修改用户组的属性

```python
groupmod [选项] 用户组
```

‍

-g GID 为用户组指定新的组标识号.   

-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同.   

-n 新用户组 将用户组的名字改为新名字

‍

示例

```python
将组group2的组标识号修改为102：
groupmod -g 102 group2

将组group2的标识号改为10000，组名修改为group3：
groupmod –g 10000 -n group3 group2

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。
groupadd group1
```

‍

‍

#### newgrp

‍

如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限. 

  
用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组

```python
newgrp root
```

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组. 类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成

‍

‍

#### groupdel

删除一个已有的用户组

```
groupdel 用户组
```

‍

‍

## 系统管理

‍

### 日期

‍

#### cal

查看当前日历

-y显示整年日历

‍

#### date

显示或设置时间

设置时间格式（需要管理员权限）

```python
date [MMDDhhmm[[CC]YY][.ss]] +format
```

MM为月，DD为天，hh为小时，mm为分钟；CC为年前两位，YY为年的后两位，ss为秒

显示时间格式（date '+%y,%m,%d,%H,%M,%S'）

‍

‍

### 进程

‍

#### ps

查看进程信息

* -a显示终端上的所有进程，包括其他用户的进程
* -u显示进程的详细状态
* -x显示没有控制终端的进程
* -w显示加宽，以便显示更多的信息
* -r只显示正在运行的进程

‍

常见用法

* ps -e   查看所有进程信息（瞬时的）
* ps -u root -N  查看所有不是root运行的进程
* ps ax   显示所有进程状态状态
* ps -ef |grep xxx 显示含有xxx的进程

‍

更多命令选项

* ps a  显示现行终端机下的所有程序，包括其他用户的程序.
* ps -A  显示所有程序.
* ps c  列出程序时，显示每个程序真正的指令名称，而不包含路  径，参数或常驻服务的标示.
* ps -e  此参数的效果和指定"A"参数相同.
* ps e  列出程序时，显示每个程序所使用的环境变量.
* ps f  用ASCII字符显示树状结构，表达程序间的相互关系.
* ps -H  显示树状结构，表示程序间的相互关系.
* ps -N  显示所有的程序，除了执行ps指令终端机下的程序之外.
* ps s  采用程序信号的格式显示程序状况.
* ps u 以用户为主的格式来显示程序状况.
* ps x 显示所有程序，不以终端机来区分.

‍

**pstree**

以树状图显示进程关系

‍

特别表明在运行的进程：

pstree -apnh //显示进程间的关系  

‍

同时显示用户名称：

pstree -u //显示用户名称

‍

#### top

动态显示进程

能够在运行后，在指定的时间间隔更新显示信息. -d参数可以指定显示信息更新的时间间隔

‍

在top命令执行后，可以按下按键得到对显示的结果进行排序

‍

* M    根据内存使用量来排序
* P    根据CPU占有率来排序
* T    根据进程运行时间的长短来排序
* U    可以根据后面输入的用户名来筛选进程
* K    可以根据后面输入的PID来杀死进程.
* q    退出
* h    获得帮助

更高级的命令是htop，但需要安装

‍

#### kill

终止进程

指定进程号的进程，需要配合 ps 使用

信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程

‍

```python
kill [-signal] pid
```

‍

‍

### 电源

‍

#### reboot,**shutdown,init**

‍

* reboot    重新启动操作系统

* shutdown –r now    重新启动操作系统，shutdown会给别的用户提示
* shutdown -h now    立刻关机，其中now相当于时间为0的状态
* shutdown -h XXX    系统在今天的XXX会关机
* shutdown -h +10    系统再过十分钟后自动关机

* init 0关机
* init 6重启

‍

### 环境

‍

#### which

查找$PATH中设置命令及安装文件目录所在位置

‍

#### export

设置或显示环境变量

在 shell 中执行程序时，shell 会提供一组环境变量. export 可新增，修改或删除环境变量，供后续执行的程序使用.   
export 的效力仅限于该次登陆操作

‍

```python
export [-fnp][变量名称]=[变量设置值]
```

* -f  代表[变量名称]中为函数名称.
* -n  删除指定的变量. 变量实际上并未删除，只是不会输出到后续指令的执行环境中.
* -p  列出所有的shell赋予程序的环境变量.

‍

## 磁盘管理

‍

Linux 磁盘管理常用三个命令为 **df**、**du** 和 **fdisk**

* **df**（英文全称：disk free）：列出文件系统的整体磁盘使用量
* **du**（英文全称：disk used）：检查磁盘空间使用量
* **fdisk**：用于磁盘分区

‍

### 空间查看

‍

#### df

检测磁盘空间, 可以显示所有文件系统对节点和磁盘块的使用情况

```python
df [-ahikHTm] [目录或文件名]
```

‍

* -a     列出所有的文件系统，包括系统特有的 /proc 等文件系统；
* -k     以 KBytes 的容量显示各文件系统；
* -m     以 MBytes 的容量显示各文件系统；
* -h     以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
* -H     以 M=1000K 取代 M=1024K 的进位方式；
* -T     显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
* -i     不用硬盘容量，而以 inode 的数量来显示

‍

**实例 1**

将系统内所有的文件系统列出来！

```
[root@www ~]# df
Filesystem      1K-blocks      Used Available Use% Mounted on
/dev/hdc2         9920624   3823112   5585444  41% /
/dev/hdc3         4956316    141376   4559108   4% /home
/dev/hdc1          101086     11126     84741  12% /boot
tmpfs              371332         0    371332   0% /dev/shm
```

在 Linux 底下如果 df 没有加任何选项，那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！

‍

**实例 2**

将容量结果以易读的容量格式显示出来

```
[root@www ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
/dev/hdc3             4.8G  139M  4.4G   4% /home
/dev/hdc1              99M   11M   83M  12% /boot
tmpfs                 363M     0  363M   0% /dev/shm
```

‍

**实例 3**

将系统内的所有特殊文件格式及名称都列出来

```
[root@www ~]# df -aT
Filesystem    Type 1K-blocks    Used Available Use% Mounted on
/dev/hdc2     ext3   9920624 3823112   5585444  41% /
proc          proc         0       0         0   -  /proc
sysfs        sysfs         0       0         0   -  /sys
devpts      devpts         0       0         0   -  /dev/pts
/dev/hdc3     ext3   4956316  141376   4559108   4% /home
/dev/hdc1     ext3    101086   11126     84741  12% /boot
tmpfs        tmpfs    371332       0    371332   0% /dev/shm
none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc
sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs
```

‍

**实例 4**

将 /etc 底下的可用的磁盘容量以易读的容量格式显示

```
[root@www ~]# df -h /etc
Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
```

‍

‍

#### **du**

检测目录所占磁盘空间

统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更侧重于磁盘的使用状况

```python
du [-ahskm] 目录或文件名
```

‍

du没有加任何选项时，只列出当前目录下的所有文件夹容量（包括隐藏文件夹）

* -a     列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已.
* -h     以人们较易读的容量格式 (G/M) 显示；
* -s     列出总量而已，而不列出每个各别的目录占用容量；
* -S     不包括子目录下的总计，与 -s 有点差别.
* -k     以 KBytes 列出容量显示；
* -m     以 MBytes 列出容量显示；

‍

‍

### 分区

#### fdisk

‍

磁盘分区表操作工具

```python
fdisk [-l] 装置名称
```

‍

-l ：输出后面接的装置所有的分区内容. 若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来

‍

离开 fdisk 时按下 q ，那么所有的动作都不会生效！相反的， 按下 w 就是动作生效的意思

使用 p  可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态

‍

‍

‍

### 维护

‍

#### mkfs

磁盘格式化（make filesystem）

```python
mkfs [-t 文件系统格式] 装置文件名
```

-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)

‍

‍

#### fsck

磁盘检验

‍

file system check用来检查和维护不一致的文件系统

若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查. 

‍

```
fsck [-t 文件系统] [-ACay] 装置名称
```

* -t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数
* -s : 依序一个一个地执行 fsck 的指令来检查
* -A : 对/etc/fstab 中所有列出来的 分区（partition）做检查
* -C : 显示完整的检查进度
* -d : 打印出 e2fsck 的 debug 结果
* -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行
* -R : 同时有 -A 条件时，省略 / 不检查
* -V : 详细显示模式
* -a : 如果检查有错则自动修复
* -r : 如果检查有错则由使用者回答是否修复
* -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复.

‍

‍

‍

#### mount

磁盘挂载与卸除 umount

‍

```python
mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点
```

-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下  
-n ：不升级 /etc/mtab 情况下卸除

‍

磁盘卸载命令 `umount`​ 

```
umount [-fn] 装置文件名或挂载点
```

选项与参数：

* -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；
* -n ：不升级 /etc/mtab 情况下卸除.

‍

‍

‍

## 多机交互

‍

‍

### 防火墙

‍

#### firewall

firewall-cmd是Linux中专门用于控制防火墙的命令

‍

‍

‍

#### systemctl

systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作

‍

‍

‍

### 网络

‍

#### netstat

查看网络状态

```python
netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]
```

‍

* -a或--all     显示所有连线中的Socket.
* -A<网络类型>或--<网络类型>     列出该网络类型连线中的相关地址.
* -c或--continuous     持续列出网络状态.
* -C或--cache     显示路由器配置的快取信息.
* -e或--extend     显示网络其他相关信息.
* -F或--fib     显示FIB.
* -g或--groups     显示多重广播功能群组组员名单.
* -h或--help     在线帮助.
* -i或--interfaces     显示网络界面信息表单.
* -l或--listening     显示监控中的服务器的Socket.
* -M或--masquerade     显示伪装的网络连线.
* -n或--numeric     直接使用IP地址，而不通过域名服务器.
* -N或--netlink或--symbolic     显示网络硬件外围设备的符号连接名称.
* -o或--timers     显示计时器.
* -p或--programs     显示正在使用Socket的程序识别码和程序名称.
* -r或--route    显示Routing Table.
* -s或--statistice     显示网络工作信息统计表.
* -t或--tcp     显示TCP传输协议的连线状况.
* -u或--udp     显示UDP传输协议的连线状况.
* -v或--verbose     显示指令执行过程.
* -V或--version     显示版本信息.
* -w或--raw     显示RAW传输协议的连线状况.
* -x或--unix     此参数的效果和指定"-A unix"参数相同.
* --ip或--inet     此参数的效果和指定"-A inet"参数相同.

‍

‍

#### ifconfig

查看或配置网卡信息

‍

修改IP地址  
ifconfig eth0 192.168.12.22(重启后无效)

‍

#### ping

测试远程主机/网络连通性

‍

‍

#### hostname

修改主机名&ip地址

显示主机名：hostname  
临时修改：hostname xxx  
永久修改: 对于centos系统 vim /etc/sysconfig/network

‍

‍

### 远程连接

‍

#### ssh

远程免密登陆

‍

假如 A  要登陆  B, 在A上操作：

首先生成密钥对, 再将A自己的公钥拷贝并追加到B的授权列表文件authorized_keys中

```python
ssh-keygen (提示时，直接回车即可)
ssh-copy-id B
```

‍

#### scp

远程文件复制

‍

用于 Linux 之间复制文件和目录

scp是 secure copy 的缩写, 是linux系统下基于ssh登陆进行安全的远程文件  
拷贝命令

scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版. 

使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的. 

‍

-P 参数来设置命令的端口号：

```python
#scp 命令使用端口号 4588
scp -P 4588 remote@xiaoxiaoming.xyz:/usr/local/sin.sh /home/administrator
```

‍

从本地复制到远程命令格式

```python
复制文件
scp local_file remote_username@remote_ip:remote_folder 
或者 
scp local_file remote_username@remote_ip:remote_file 
或者 
scp local_file remote_ip:remote_folder 
或者 
scp local_file remote_ip:remote_file
复制文件夹
scp -r local_folder remote_username@remote_ip:remote_folder 
或者 
scp -r local_folder remote_ip:remote_folder
```

‍

从远程复制到本地

```python
scp root@xiaoxiaoming.xyz:/home/root/others/music /home/space/music/1.mp3 
scp -r xiaoxiaoming.xyz:/home/root/others/ /home/space/music/
```

‍

‍

# 软件

‍

## 类型

‍

### 源码包

‍

优点：  
  开源：如果有足够能力，可以修改源代码  
  可以自由选择所需的功能  
  软件是编译安装，所以更加适合自己的系统，更加稳定也效率高  
  卸载方便：直接删除文件夹  
 

缺点：  
  安装过程步骤较多，尤其是安装较大的软件集合（如：LAMP环境搭建），容易出现拼写  
  错误  
  编译时间较长，安装比二进制安装时间长  
  因为是编译安装，安装过程中一旦报错新手很难解决  

‍

### rpm包

二进制包：与源代码区别就是源代码包经过编译成为机器能直接识别的二进制包  
 

优点：  
  包管理系统简单，只需要几个命令就可以实现包的安装、升级、查询和卸载  
  安装速度比源码包快  
 

缺点：  
  经过编译，不可以看到源代码  
  功能选择不如源代包灵活  
  依赖性  

‍

‍

## 管理

‍

### 依赖性问题

‍

‍

‍

### 查询软件是否安装

```java
使用：
rpm -q 包名
	选项：
		-q（query）			查询
		-a（all）			所有
```

‍

‍

## YUM

小黄狗

yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器. 

基于RPM包管理，能够从指定的**服务器(YUM服务器, 也就是软件集合, 有软件包索引和依赖关系数据)**

自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装. 

yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记. 方便便捷，**依赖自动解决(不用自己去配了)**

‍

‍

‍

### 管理

‍

‍

#### 查询可用软件列表

‍

​​yum list

yum search 关键字

‍

‍

#### 更新

国内yum源

‍

网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错.   

将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到.   

‍

```python
首先备份/etc/yum.repos.d/CentOS-Base.repo

mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup

下载对应版本 repo 文件, 放入 /etc/yum.repos.d/
CentOS7 ：http://mirrors.163.com/.help/CentOS7-Base-163.repo

wget http://mirrors.163.com/.help/CentOS7-Base-163.repo
mv CentOS7-Base-163.repo /etc/yum.repos.d/CentOS-Base.repo
```

‍

运行以下命令生成缓存

```python
yum clean all
yum makecache
```

‍

‍

### 命令

‍

#### yum

‍

```python
yum [options] [command] [package ...]
```

‍

* options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等  
  等.
* command：要进行的操作.
* package：操作的对象.

‍

‍

实例：

* 列出所有可更新的软件清单命令：     yum check-update
* 更新所有软件命令：     yum update
* 仅安装指定的软件命令：     yum install <package_name>
* 仅更新指定的软件命令：     yum update <package_name>
* 显示包信息：     yum info <package_name>
* 列出所有可安裝的软件清单命令：     yum list
* 删除软件包命令：     yum remove <package_name> (会同时卸载依赖)
* 查找软件包 命令：     yum search <keyword>
* 清除缓存命令:

    yum clean packages:   清除缓存目录下的软件包  
    yum clean headers:   清除缓存目录下的 headers  
    yum clean oldheaders:   清除缓存目录下旧的 headers  
    yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers

‍

‍

#### 安装

==yum会自动安装依赖，很方便==

```java
yum -y install 包名
	选项：
		install				安装
		-y					自动回答yes
```

‍

‍

#### 升级

此时注意如果不加包名：会出现把所有软件包都升级包括Linux内核，但是Linux升级完成后需要在本地进行配置，如果是远程服务器管理的话，你会出现==服务器永远启动不了==

```java
yum -y updata 包名
	选项：
		updata				升级
		-y					自动回答yes
```

‍

‍

#### 卸载

==yum卸载会把依赖也卸载，要注意==

```java
yum -y remove 包名
	选项：
		remove				卸载
		-y					自动回答yes
```

‍

‍

## RPM

Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装

可以看到 `软件名-版本号-适应硬件架构`​

‍

* noarch适合任何版本
* X86/64

‍

‍

|RPM包默认安装路径|文件含义|
| -------------------| ----------------------------|
|/etc|配置文件安装目录|
|/usr/bin|可执行的命令安装目录|
|/usr/lib|程序所使用的函数库保存位置|
|/usr/share/doc|基本的软件使用手册保存位置|
|usr/share/man|帮助文件保存位置|

‍

‍

‍

### 命令

‍

* rpm -ivh <rpm包名>     安装软件
* rpm -e <rpm包名>     卸载安装
* rpm -qi <rpm包名>   显示软件安装信息
* rpm -qa | grep xxx     查询软件是否安装（包括相关依赖）
* rpm -Uvh <rpm包名>      升级一个rpm

‍

具体参数详解：

* -i, --install  安装包
* -v, --verbose  列出更多详细信息，**安装进度**
* -h, --hash  安装时列出hash标记 (与 -v连用)
* -e, --erase  卸载安装包
* -U, --upgrade=+  升级包

  * --replacepkge              无论软件包是否已被安装，都强行安装软件包
  * --test                            安装测试，并不实际安装
  * --nodeps                      忽略软件包的依赖关系强行安装(其他也可用)
  * --force                          忽略软件包及文件的冲突
* -q, --query  查询

  * -a, --all  查询/校验所有的安装包
  * -p, --package 查询/校验一个安装文件
  * -l, --list  列出安装文件
  * -d, --docfiles 列出所有文档文件
  * -f, --file  查询/校验安装包中所包含的文件

‍

‍

## 压缩包

‍

‍

解压后直接使用

解压完最好先看README.md

使用对应压缩命令，把软件解压后直接使用

‍

‍

‍
