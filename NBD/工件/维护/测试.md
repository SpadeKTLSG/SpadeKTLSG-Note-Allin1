‍

‍

### Header

这里的测试是项目之外的测试工具, 与对应巨构中的调试内涵不同

‍

‍

#### 速查

SPRING测试注解要求

> 类 + @SpringTest
>
> 方法 + @Test
>
> 注入对应的对象

‍

‍

‍

# 知识

‍

## 类型

‍

测试里面的种类

* 单元测试

  * 完成最小的软件设计单元的验证工作，目标是确保模块被正确的编码
* 黑盒测试

  * 不考虑内部结构，主要测试功能十分满足需求
* 白盒测试

  * 针对代码级别，测试开发工程师一般具备白盒测试能力，针对程序内部的逻辑结构进行代码级别的测试
* 回归测试

  * 对原先提出的缺陷进行二次验证，开发人员修复后进行二次的验证
* 集成测试

  * 测试模块和模块之间的整合，且测试主要的业务功能
* 系统测试

  * 针对整个产品系统进行的测试，验证系统是否满足产品业务需求

‍

### 冒烟测试<sup>（Smoke Testing）</sup>

    完成一个新版本的开发后，对该版本**最基本**的功能进行测试，保证基本的功能和流程**能走通**  
    不通过则打回重新开发；通过才会进行下一步的测试(功能测试，集成测试，系统测试...)

‍

### 单元测试<sup>（Unit Testing）</sup>

    是指对软件中的最小可测试单元进行检查和验证. 至于“单元”的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统

‍

### 边界测试<sup>（Limit testing）</sup>

    也可叫临界测试: 如果一个方法接收的是int类型的参数，那以下三个值是必测的：0、正最大、负最小，其中正最大和负最小是边界值

‍

‍

## 概念

**测试覆盖度** 是衡量测试过程中被测试到的代码量的一个指标，一般情况下越高越好. 测试覆盖度 100% 表示整个系统中所有的方法和关键语句都被测试到了. 

‍

‍

# 基础

‍

‍

‍

## 单元测试

‍

### mock

‍

‍

‍

## 集成测试

一份全面完整的单元测试报告，便于查看单元测试覆盖度、评估测试效果和定位问题. 

‍

‍

‍

### IDEA单测报告

直接在 IDEA 开发工具中选择 `Run xxx with Coverage`​ 执行单元测试类

‍

### jacoco单测报告

[官方文档](https://link.juejin.cn?target=https%3A%2F%2Fwww.eclemma.org%2Fjacoco%2Ftrunk%2Fdoc%2Fmaven.html)

JaCoCo 是一个常用的 Java 代码覆盖度工具，能够自动根据单元测试执行结果生成详细的单测报告. 

‍

通常这种方式会更适用于企业中配置流水线来自动化生成测试报告的场景

‍

# 其他

‍

## 测试这事的评价

‍

> 能用vitest或者jest都不错了 实际上根本没时间进行太多复杂测试

> 感觉单测，没有必要跑@SpringBootTest吧. 太慢了. 对于特别是你要生成完整项目单测报告的话，那也太久了. 感觉应该校验被测service的代码逻辑即可，对外部service，mapper执行结果都采用mock的方式. 不仅执行效率快，定位问题也清晰. 否则你A service 单测的报错，会让B service 单测也跟着报错，这是不应该的，因为我 B service 只管自己的业务就行.

> 单元测试并非一无是处，只不过测试的代码应该是纯粹的某个功能，而非业务流程，就比如下单，那么下单这个流程就不适合单元测试，但是下单中有个计算订单金额的函数方法却是需要做单元测试.

> 很多人刚开始接触单元测试的时候，都去网上学习怎么写单元测试，但是很多文章介绍单元测试都只拿“纯函数”的测试举例子，然后看过之后就照猫画虎到实际项目写测试代码了，结果就是很难写出来，或者写出来起不到验证的作用，于是就在脑海中形成一个单元测试没啥用的错误观念，实际单元测试对要测试的代码是有要求的，它是用于对代码某个最小片段的验证，这个片段不能有太多的依赖源，虽然依赖源可以mock掉，但是实际项目中，如果把某个要测试单元的依赖数据mock掉，往往测不出什么问题，而如果从db或者cache取依赖数据，就不叫单元测试了，所以一般业务系统大多数场景用不上单元测试，更多的是集成测试与功能测试，另外提一嘴，单元测试也要求写代码的人具备一定代码水平的，屎山代码可没法做单元测试

> 关于测试和生产问题  
> 谁写这个鬼东西 先做出来再说 后面再改bug  
> 拖时间太多 大部分领导会认为你不行 不管你后面写的代码有多好

‍
